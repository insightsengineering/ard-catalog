---
title: "QCing Laboratory Test Results and Change from Baseline by Visit (LBT01)"
editor: source
format: 
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show the code"
    code-overflow: scroll 
    df-print: kable
---

## Laboratory Test Results and Change from Baseline by Visit (LBT01) QC Workflow

#### 1. Generate a table using {chevron}

Using the `lbt01_main` function from the {chevron} package to generate a Lab Results Table. We'll add an overall column to walk through the QCing steps if your table has an overall column.

```{r}
#| message: false
#| code-summary: "Show the code"
library(chevron)

# Create a table using the chevron package 
tlg_lbt01 <- chevron::lbt01_main(syn_data, lbl_overall = "Overall ARM")
head(tlg_lbt01, n = 15) #truncated display

```

#### 2. Flatten the table into a data.frame

A rtables based output can be flattened into a data frame using the `as_results_df()` function from the rtables package. The `make_ard` argument set to `TRUE`, will format the data similar to the output generated by the {cards}/{cardx} package.

```{r, warning=FALSE}
rtables_result <- rtables::as_result_df(tlg_lbt01, make_ard = TRUE, expand_colnames = TRUE)
```

#### 3. Create a comparable ARD

Using the `ard_continuous` function, we will compute the lab results statistics. 
Notice how there are multiple variables specified by `by`: observations will be grouped in that sequence before calculating the statistics for the variables listed in `variables`. 
If your table is pruning unobserved levels during calculation, the `by` parameter should be replaced with the `strata` parameter (more detail described in the documentation [here](https://insightsengineering.github.io/cards/latest-tag/reference/ard_continuous.html#arg-by-strata)).

To calculate the statistics for the overall column, the code should look similar to the prior calculation with the "ARM" variable removed from the `by` (or `strata`) parameter (indicating the data is not stratified by "ARM").

We'll keep the stats for the overall column in a separate dataframe to generalize this workflow.

```{r}
#| code-fold: false
#| code-summary: "Show the code"
library(cards)
library(dplyr)

adlb <- chevron::syn_data$adlb

ard_result <- ard_continuous(adlb, 
                             by = c(ACTARM, PARAMCD, AVISIT), 
                             variables = c(AVAL, CHG), 
                             statistic = 
                               list(everything() ~ continuous_summary_fns(c("N", "mean", "sd", "median", "min", "max"))))

# calculate overall statistics
ard_overall <- ard_continuous(adlb, 
                             by = c(PARAMCD, AVISIT), # note arm var is removed
                             variables = c(AVAL, CHG), 
                             statistic = 
                               list(everything() ~ continuous_summary_fns(c("N", "mean", "sd", "median", "min", "max"))))

```

### Statistics comparison

#### 1. rtables reformat

Some reformatting is required to ensure the resulting dataframes are compatible. Most of the reformatting is adjusting the column names to match that of the ARD result.

1.  rename `group1` and `group1_level`, `ARM` and `ARM` levels accordingly.
2.  rename `group2` and `group2_level`, `PARAMCD` and `PARAMCD` levels accordingly.
3.  rename `group3` and `group3_level`, `AVISIT` and `AVISIT` levels accordingly.
4.  recode `stat` `n` value to `N` to match ARD
5.  Select columns relevant to comparison

We'll also separate the statistics related to the overall ARM to match the `ard_overall` object.

```{r}

rtables_result <- rtables_result |>
  dplyr::mutate(stat_name = dplyr::recode(stat_name, "n" = "N"),
                group4_level = dplyr::recode(group4_level, 
                                             "Analysis Value" = "AVAL",
                                             "Absolute Change from Baseline" = "CHG")) |>
  dplyr::rename(group1 = group3,
                group1_level = group3_level,
                group2 = group1,
                group2_level = group1_level,
                group3 = group2,
                group3_level = group2_level,
                variable = group4_level,
                # giving a dummy name for this column so it doesn't interfere with the column renaming
                val = variable) |>
  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat))

rtables_result_overall <- rtables_result |>
  dplyr::filter(group1_level == "Overall ARM")

# remove the overall observations from the results df
rtables_result <- rtables_result |>
  dplyr::filter(group1_level != "Overall ARM")


```
Based on dimensions alone - we can see that tables likely generated similar results

```{r, eval=TRUE}
nrow(rtables_result)
nrow(ard_result)

nrow(rtables_result_overall)
nrow(ard_overall)
```

##### 2. ARD reformat

We'll also need some format adjustment for the ARD object. Primarily, converting lists to vectors (character or numeric) to match the rtables_result format. Not doing so will result in an incompatible comparison error.

1.  Select columns relevant to comparison
2.  Convert any list columns to character and numeric
3.  convert any "NaN" stats to "NA" to match rtables

```{r}

ard_result <- ard_result |>
  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat)) |>
  dplyr::mutate(
  group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) > 0, as.numeric(.x[[1]]), NA_character_)),
  stat = dplyr::recode(stat, `NaN` = NA_real_))

# to the overall ard_result, rename the cols to match the rtables df

ard_overall <- ard_overall |>
  dplyr::rename(group2 = group1,
                group2_level = group1_level,
                group3 = group2,
                group3_level = group2_level) |>
   dplyr::mutate(group1 = "ACTARM",
                 group1_level = "Overall ARM",
  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) > 0, as.numeric(.x[[1]]), NA_character_)),
  stat = dplyr::recode(stat, `NaN` = NA_real_)) |>
  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat))
  

```

#### 3. Compare programmatically

Use the diffdf package to compare the results.

```{r, eval=TRUE}

library(diffdf)

diffdf(ard_result, rtables_result, keys = c("group1", "group1_level", "group2", "group2_level", "group3", "group3_level", "variable", "stat_name", "stat"), suppress_warnings = TRUE)

```


##### Compare the overall_arm

```{r, eval=TRUE}

diffdf(ard_overall, rtables_result_overall, keys = c("group1", "group1_level", "group2", "group2_level", "group3", "group3_level", "variable", "stat_name", "stat"), suppress_warnings = TRUE)

```
