---
title: "QCing Laboratory Test Results and Change from Baseline by Visit (LBT01)"
editor: source
format: 
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show the code"
    code-overflow: scroll 
    df-print: kable
---

## Laboratory Test Results and Change from Baseline by Visit (LBT01) QC Workflow

#### 1. Generate a table using {chevron}

```{r}
#| message: false
#| code-summary: "Show the code"
library(chevron)

# Create a table using the chevron package 
tlg_lbt01 <- chevron::lbt01_main(syn_data, lbl_overall = "Overall ARM")
tlg_lbt01

```

#### 2. Flatten the table into a data.frame

A rtables based output can be flattened into a data frame using the `as_results_df()` function from the rtables package. The `make_ard` argument set to `TRUE`, will format the data similar to the output generated by the {cards} package.

```{r}
rtables_result <- rtables::as_result_df(tlg_lbt01, make_ard = TRUE, expand_colnames = TRUE)
results[1:6, -c(1:3)]
```

#### 3. Create a comparable ARD

Using the {cards} package, we stack the functions `ard_continuous()` for the continuous variables and `ard_categorical()` for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.

If any variable manipulation was done to the data prior to running the citril/chevron/tern/rtables commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.

Note: when a 'by' variable is specified in the  `ard_stack()` call, a univariate tabluation is returned. We will have to remove those obervations later in the workflow to create a 1:1 match. 

```{r}
#| code-fold: false
#| code-summary: "Show the code"
library(cards)
library(tern)
library(dplyr)

adsl <- syn_data$adsl
adlb <- syn_data$adlb

# Ensure character variables are converted to factors and empty strings and NAs are explicit missing levels.
adsl <- df_explicit_na(adsl)
adlb <- df_explicit_na(adlb) %>%
  filter(ANL01FL == "Y")

ard_result <- ard_continuous(adlb, 
                             by = c(ACTARM, PARAMCD, AVISIT), 
                             variables = c(AVAL, CHG), 
                             statistic = list(everything() ~ continuous_summary_fns(c("N", "mean", "sd", "median", "min", "max"))))

### How to calculate overall?

overall <- ard_stack(adlb, 
          .by =c(ARM, PARAM, AVISIT),
          .overall = TRUE,
          ard_continuous(variables = c(AVAL, CHG), 
                             statistic = list(everything() ~ continuous_summary_fns(c("N", "mean", "sd", "median", "min", "max")))))
```

### Statistics comparison

#### 1. rtables reformat

1. rename `group1` and `group1_level`, `ARM` and `ARM` levels accordingly. 
2. rename `group2` and `group2_level`, `PARAMCD` and `PARAMCD` levels accordingly. 
3. rename `group3` and `group3_level`, `AVISIT` and `AVISIT` levels accordingly. 
4. recode `stat` `n` value to `N` to match ARD
5. Select columns relevant to comparison


```{r}

rtables_result <- rtables_result |>
  dplyr::mutate(stat_name = dplyr::recode(stat_name, "n" = "N"),
                group4_level = dplyr::recode(group4_level, "Analysis Value" = "AVAL", "Absolute Change from Baseline" = "CHG")) |>
  dplyr::rename(group1 = group3,
                group1_level = group3_level,
                group2 = group1,
                group2_level = group1_level,
                group3 = group2,
                group3_level = group2_level,
                variable = group4_level,
                # giving a dummy name for this column so it doesn't interfere with the column renaming
                val = variable) |>
  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat)) |>
  # filter out overall col for now
  dplyr::filter(group1_level != "Overall ARM")


```

##### 2. ARD reformat

1. Select columns relevant to comparison
2. Convert any list columns to character and numeric
3. convert any "NaN" stats to "NA" to match rtables

```{r}

ard_result <- ard_result |>
  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat)) |>
  dplyr::mutate(
  group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) > 0, as.numeric(.x[[1]]), NA_character_)),
  stat = dplyr::recode(stat, `NaN` = NA_real_))

```


#### 3. Compare programmatically

Use the diffdf package to compare the results.

```{r}

library(diffdf)

diffdf(ard_result, rtables_result, keys = c("group1", "group1_level", "group2", "group2_level", "group3", "group3_level", "variable", "stat_name", "stat"), suppress_warnings = TRUE)

```


