---
title: "QCing Time-to-event Summary (TTET01)"
editor: source
format: 
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show the code"
    code-overflow: scroll 
    df-print: kable
---

## Time-to-event Summary (TTET01) QC Workflow

#### 1. Generate a table using {chevron}

```{r}
#| message: false
#| code-summary: "Show the code"
library(chevron)

# Create a table using the chevron package 
proc_data <- dunlin::log_filter(syn_data, PARAMCD == "PFS", "adtte")
tlg_ttet01 <- chevron::run(ttet01, proc_data)
tlg_ttet01

```

#### 2. Flatten the table into a data.frame

A rtables based output can be flattened into a data frame using the `as_results_df()` function from the rtables package. The `make_ard` argument set to `TRUE`, will format the data similar to the output generated by the {cards} package.

```{r, warning=FALSE}
results <- rtables::as_result_df(tlg_ttet01, make_ard = TRUE, expand_colnames = TRUE)
```

#### 3. Create a comparable ARD

Using the {cards} package, we stack the functions `ard_continuous()` for the continuous variables and `ard_categorical()` for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.

If any variable manipulation was done to the data prior to running the citril/chevron/tern/rtables commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.

Note: when a 'by' variable is specified in the  `ard_stack()` call, a univariate tabluation is returned. We will have to remove those obervations later in the workflow to create a 1:1 match. 

```{r}
#| code-fold: false
#| code-summary: "Show the code"
library(cards)
library(dplyr)
library(survival)
library(cardx)

adtte <- proc_data$adtte |>
  dplyr::mutate(AVAL = (AVAL/ 30.4375), #convert days to months, this is the same calculation chevron uses.
                is_event = CNSR == 0,
                is_not_event = CNSR == 1)

# Event Rates
event_rates <- bind_ard(
  # Patient Event Rates
  ard_categorical(adtte, strata = c(ARM), variable = c(CNSR), statistic = everything()~c("n", "p")),
  # Earliest Contributing Event
  ard_categorical(adtte |> dplyr::filter(CNSR == 0), strata = c(ARM), variable = c(EVNTDESC), statistic = everything()~c("n"))
)

# Time to Event
tte <- bind_ard(
  # calculate median
  survfit(Surv(AVAL, 1-CNSR) ~ ARM, data = adtte) |>
  ard_survival_survfit(probs = 0.5), 
  # calculate quantiles
  survfit(Surv(AVAL, 1-CNSR) ~ ARM, data = adtte) |>
  ard_survival_survfit(probs = c(0.25, 0.75)) |>
  filter(stat_name == "estimate"),
  # calculate range
  ard_continuous(adtte, by = c(ARM), variable = c(AVAL), statistic = ~ continuous_summary_fns(c("min", "max")))
)

# Unstratified Analysis
ard_logrank <-
  ard_survival_survdiff(
    formula = Surv(AVAL, CNSR) ~ ARM,
    data = adtte
  )

# difference in event free rate
event_free <- survfit(Surv_CNSR() ~ ARM, data = adtte) |>
  ard_survival_survfit_diff(times = 6) |>
  filter(stat_name %in% c("estimate", "conf.low", "conf.high", "p.value"))


# unstratified pairwise
surv_fit <- coxph(Surv(AVAL, is_event) ~ ARM, data = adtte_f)
library(cardx)
library(survival)

  
ard_coxph <-
  coxph(Surv(AVAL, 1 - CNSR) ~ ARM, data = adtte) |> 
  ard_regression() |> 
  dplyr::filter(stat_name %in% c("estimate", "conf.low", "conf.high"))

# 6 months analysis
six_mo <- survfit(Surv(AVAL, 1-CNSR) ~ ARM, adtte) |> ard_survival_survfit(time = 6)

```

```{r}
```




### Statistics comparison

#### 1. rtables reformat


##### 2. ARD reformat


#### 3. Compare programmatically

