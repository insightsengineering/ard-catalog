---
title: "QCing Time-to-event Summary (TTET01)"
editor: source
format: 
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show the code"
    code-overflow: scroll 
    df-print: kable
---

## Time-to-event Summary (TTET01) QC Workflow

#### 1. Generate a table using {chevron}

```{r}
#| message: false
#| code-summary: "Show the code"
library(chevron)

# Create a table using the chevron package 
proc_data <- dunlin::log_filter(syn_data, PARAMCD == "PFS", "adtte")
tlg_ttet01 <- chevron::run(ttet01, proc_data)
tlg_ttet01

```

#### 2. Flatten the table into a data.frame

A rtables based output can be flattened into a data frame using the `as_results_df()` function from the rtables package. The `make_ard` argument set to `TRUE`, will format the data similar to the output generated by the {cards} package.

```{r}
results <- rtables::as_result_df(tlg_ttet01, make_ard = TRUE, expand_colnames = TRUE)
results[1:6, -c(1:3)]
```

#### 3. Create a comparable ARD

Using the {cards} package, we stack the functions `ard_continuous()` for the continuous variables and `ard_categorical()` for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.

If any variable manipulation was done to the data prior to running the citril/chevron/tern/rtables commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.

Note: when a 'by' variable is specified in the  `ard_stack()` call, a univariate tabluation is returned. We will have to remove those obervations later in the workflow to create a 1:1 match. 

```{r}
#| code-fold: false
#| code-summary: "Show the code"
library(cards)
library(tern)
library(dplyr)


adtte <- proc_data$adtte

adtte_f <- adtte %>%
  dplyr::filter(PARAMCD == "PFS") %>%
  dplyr::mutate(
    AVAL = day2month(AVAL),
    is_event = CNSR == 0,
    is_not_event = CNSR == 1,
    EVNT1 = factor(
      case_when(
        is_event == TRUE ~ "Patients with event (%)",
        is_event == FALSE ~ "Patients without event (%)"
      ),
      levels = c("Patients with event (%)", "Patients without event (%)")
    ),
    EVNTDESC = factor(EVNTDESC)
  )


library(survival)
library(cardx)
library(ggsurvfit)
# Patients with events
ard_result <- ard_categorical(adtte_f, by = ARM, variable = c(is_event))
# time to event
t <- ard_categorical(adtte_f, by = c(ARM, EVNT1), variable = c(EVNTDESC))

  conf_int <- function(x) {
    t.test(x, conf.level = 0.95)[["conf.int"]] |>
      as.list() |>
      rlang::set_names(c("conf.low", "conf.high"))
  }
time2event <- ard_continuous(adtte_f, by = ARM, variable = c(AVAL), statistic = list(everything() ~ continuous_summary_fns(c("median", "p25", "p75", "min", "max"))))

time2eventci <- ard_continuous(adtte_f, by = ARM, variable = c(AVAL), statistic = ~list(conf_int = conf_int))

# 6 months analysis
six_mo <- survfit(Surv(AVAL) ~ ARM, adtte_f) |> ard_survival_survfit(time = c(6))

# difference in event free rate
event_free <- survfit(Surv_CNSR() ~ ARM, data = adtte_f) |>
  ard_survival_survfit_diff(times = c(6,12))


# unstratified pairwise
surv_fit <- coxph(Surv(AVAL, is_event) ~ ARM, data = adtte_f)


```

### Statistics comparison

#### 1. rtables reformat


##### 2. ARD reformat


#### 3. Compare programmatically

