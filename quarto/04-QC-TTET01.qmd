---
title: "QCing Time-to-event Summary (TTET01)"
editor: source
format: 
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show the code"
    code-overflow: scroll 
    df-print: kable
---

## Time-to-event Summary (TTET01) QC Workflow

#### 1. Generate a table using {chevron}

```{r}
#| message: false
#| code-summary: "Show the code"
library(chevron)

# Create a table using the chevron package 
proc_data <- dunlin::log_filter(syn_data, PARAMCD == "PFS", "adtte")
ttet01 <- run(ttet01, proc_data)
ttet01

```

#### 2. Flatten the table into a data.frame

A rtables based output can be flattened into a data frame using the `as_results_df()` function from the rtables package. The `make_ard` argument set to `TRUE`, will format the data similar to the output generated by the {cards} package.

```{r}
results <- rtables::as_result_df(ttet01, make_ard = TRUE, expand_colnames = TRUE)
results[1:6, -c(1:3)]
```

#### 3. Create a comparable ARD

Using the {cards} package, we stack the functions `ard_continuous()` for the continuous variables and `ard_categorical()` for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.

If any variable manipulation was done to the data prior to running the citril/chevron/tern/rtables commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.

Note: when a 'by' variable is specified in the  `ard_stack()` call, a univariate tabluation is returned. We will have to remove those obervations later in the workflow to create a 1:1 match. 

```{r}
#| code-fold: false
#| code-summary: "Show the code"
library(cards)

# build ARDs that calculate relevant statistics for continuous and categorical variables.

ards <- ard_stack(syn_data$adsl, ard_continuous(variables = c(AGE), statistic = ~ continuous_summary_fns(c("N", "mean", "sd", "median", "min", "max"))
  ),
                 ard_categorical(variables = c(AGEGR1, SEX, ETHNIC, RACE)),
                 .by = "ARM",
                 .overall = TRUE)

ards [1:6, -c(1,9:11)]
```

### Statistics comparison

#### 1. rtables reformat

In order to compare the two data.frames programatically, some identifying variables must align to be used as "key columns". Below are some data wrangling steps used to match the statistics for comparison. Note the rtables output:

```{r}
tail(results[, -c(1:3)])
```

The `variable_level` leads with the statistic name, followed by "." and then the actual level that matches the `variable_level` in the ARD object. We will mutate the level to match the level values in the ard object. Similarly, the total number of observations for a group is labelled "N" in the ARD object, while it is named "n" in the rtables object. The following manipulations are completed below:

1.  Set the `variable_level` to NA in the rtables result for a continuous data summary (as variable levels don't apply and is NULL in the ARD object).
2.  Remove the stat_name (ie. "count") before the variable level.
3.  Convert the "n":"N" and "count":"n".
4.  Recode the variable AAGE to AGE.
5.  Recode the `SEX` variable Male:M, Female:F. Note: if you are mapping variables in {citril}, these changes would already be captured.
6.  Let's remove columns we know won't be in the ard dataframe for simplicity (ie. stat_string and variable label)

```{r}

reformat <- results |>
  dplyr::mutate(
    variable_level = dplyr::case_when(
      variable_level %in% c("mean_sd", "median", "range", "n") ~ NA_character_,
      TRUE ~ variable_level
    ),
    variable_level = sub("^[^.]*\\.", "", variable_level),  # use variable_label
    stat_name = dplyr::recode(stat_name, "n" = "N", "count" = "n"),
    variable = dplyr::recode(variable, "AAGE" = "AGE"),
    variable_level = dplyr::recode(variable_level, "Male" = "M", "Female" = "F")
  ) |> dplyr::select(-c("variable_label", "stat_string"))

```

Notice, in the {rtables} output, any missing or "0" observations are pruned from the resulting table. ARDs capture statistics, even for 0 observations (and therefore has more rows than the rtables result). We can remove those rows before comparison to isolate for rows that are different between the two results.

```{r}

reformat <- reformat |>
  dplyr::filter(stat != 0,
               !(variable_label == "n" & variable_level == "n"))

```

##### 2. ARD reformat

A reformatting step is necessary for the ARD output to complete the comparison. Note that many of the columns in the {cards} objects are a list (for example, the level of the variable followed by the levels available for the factor).

```{r}
ards$group1_level[1]
```

We will pull the first string from the list for the data frame (group1_level, variable_level). We'll also add the string "ARM" to any NULL observations in the `group1` column.

```{r}
ards2 <- ards |>
  dplyr::mutate(
    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
    variable_level = purrr::map_chr(variable_level, ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_)),
    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) > 0, as.numeric(.x[[1]]), NA_character_)),
    group1 = dplyr::coalesce(group1, "ARM"),
    group1_level = dplyr::coalesce(group1_level, "All Patients")
  ) |>
  dplyr::select(-c("context", "fmt_fn", "stat_label", "warning", "error"))
```

Note that the ARD result is considerably larger than the rtables result (177 rows vs 120 rows). Here are a few differences:

1.  ARDs compute statistics for all levels of a variable, even if, that level is not observed in the data. We can remove any of the levels that are not in our comparison table to simplify.

```{r}
ards2 |>
  filter(variable == "ETHNIC" & variable_level == "UNKNOWN")

ards2 <- ards2 |> 
  dplyr::filter(!(variable == "ETHNIC" & variable_level == "UNKNOWN"),
                !variable == "ARM")
```

#### 3. Compare programmatically

Here we propose using the {diffdf} package to compare the statistics produced by the two table engines. {diffdf} is designed to compare two data frames and report any differences/inconsistencies to the user.

```{r}
library(diffdf)

diffdf(reformat, ards2, keys = c("group1_level","group1", "variable", "variable_level", "stat_name"), suppress_warnings = TRUE)

```

If dplyr is readily available, the `anti_join()` function can be used to isolate the differences between the two dataframes for closer analysis.

```{r}
library(dplyr)

differences <- ards2 %>% #start with the data.frames which contain greater number of rows.
  dplyr::anti_join(reformat, by = c("group1_level","group1", "variable", "variable_level", "stat_name"))  # Compare based on key columns

differences

```

### Developer Notes:

1.  should we provide a function for converting the lists in ARD columns to characters and numbers for the df comparison? Example function:

```{r}
convert_column <- function(df, columns, type = c("character", "numeric")) {
  type <- match.arg(type)
  
  for (col in columns) {
    if (is.list(df[[col]])) {  # Check if the column is of type 'list'
      if (type == "character") {
        df[[col]] <- purrr::map_chr(df[[col]], ~ ifelse(length(.x) > 0, as.character(.x[[1]]), NA_character_))
      } else if (type == "numeric") {
        df[[col]] <- purrr::map_dbl(df[[col]], ~ ifelse(length(.x) > 0, as.numeric(.x[[1]]), NA_real_))
      }
    }
  }
  return(df)
}

test <- convert_column(ards2, names(ards2))

class(test$variable_level)
class(test$group1_level)
class(test$stat)
```

2.  What's the best way to supply the variable level in the rtables output when the level is "n"? This is the overall number of observations - do we just pull the level from the row below it? It can be messy since we're assuming the sorting order of the rows. (accounts for ~ 40 rows difference)
3.  In ARDs, there's a step for supplementing "ARM" in the group column when the default is "NULL" for the "All Patients" rows.
4.  "AAGE" still exists (even after pulling the latest rtables changes).

Differences: - ARDs has stats for groups that are pruned in the table created by chevron (ex. the AGEGR1 \>=65) \~12 rows difference - ARD has rows for the split variable (ARM) - I removed them before differentiating, is that okay?

