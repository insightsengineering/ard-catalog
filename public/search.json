[
  {
    "objectID": "quarto/02-QC-AET02.html",
    "href": "quarto/02-QC-AET02.html",
    "title": "QCing Adverse Events (AET02)",
    "section": "",
    "text": "Show the code\nlibrary(chevron)\n\ntlg_aet02 &lt;- chevron:: aet02_main(syn_data, arm_var = \"ARM\", lbl_overall = \"Overall ARM\")\nhead(tlg_aet02, n=15) #truncated preview\n\n\n                                                             A: Drug X    B: Placebo   C: Combination   Overall ARM\n                                                               (N=15)       (N=15)         (N=15)         (N=45)   \n———————————————————————————————————————————————————————————————————————————————————————————————————————————————————\nTotal number of patients with at least one adverse event     13 (86.7%)   14 (93.3%)     15 (100%)      42 (93.3%) \nOverall total number of events                                   58           59             99             216    \ncl A.1                                                                                                             \n  Total number of patients with at least one adverse event   7 (46.7%)    6 (40.0%)      10 (66.7%)     23 (51.1%) \n  Total number of events                                         8            11             16             35     \n  dcd A.1.1.1.1                                              3 (20.0%)     1 (6.7%)      6 (40.0%)      10 (22.2%) \n  dcd A.1.1.1.2                                              5 (33.3%)    6 (40.0%)      6 (40.0%)      17 (37.8%) \ncl B.1                                                                                                             \n  Total number of patients with at least one adverse event   5 (33.3%)    6 (40.0%)      8 (53.3%)      19 (42.2%) \n  Total number of events                                         6            6              12             24     \n  dcd B.1.1.1.1                                              5 (33.3%)    6 (40.0%)      8 (53.3%)      19 (42.2%) \ncl B.2                                                                                                             \n  Total number of patients with at least one adverse event   11 (73.3%)   8 (53.3%)      10 (66.7%)     29 (64.4%) \n  Total number of events                                         18           15             20             53     \n  dcd B.2.1.2.1                                              5 (33.3%)    6 (40.0%)      5 (33.3%)      16 (35.6%) \n\n\n\n\n\nA {rtables} based output can be flattened into a data.frame using the as_results_df() function from the {rtables} package. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards} package. Setting the add_tbl_str_decimals to FALSE will not return a column with the statistic as a formatted string. We also include a step to remove the “label” attribute for the statistics. The diffdf() function is sensitive to attribute mismatch, so we will remove them (set to NULL) to match the ARD results exactly.\n\nrtables_result &lt;- rtables::as_result_df(tlg_aet02, make_ard = TRUE, add_tbl_str_decimals = FALSE)\nattr(rtables_result$stat, \"label\") &lt;- NULL\n\nrtables_result[1:6, -c(1:2, 7,8)]\n\n\n\n\n\ngroup2\ngroup2_level\nvariable\nvariable_level\nstat\n\n\n\n\nARM\nA: Drug X\nUSUBJID\nunique\n13.0000000\n\n\nARM\nA: Drug X\nUSUBJID\nunique\n0.8666667\n\n\nARM\nA: Drug X\nUSUBJID\nnonunique\n58.0000000\n\n\nARM\nA: Drug X\nAEBODSYS\nunique\n7.0000000\n\n\nARM\nA: Drug X\nAEBODSYS\nunique\n0.4666667\n\n\nARM\nA: Drug X\nAEBODSYS\nnonunique\n8.0000000\n\n\n\n\n\n\n\n\n\nIn the code below, we perform different data pre-processing for the different ARDs we want to create. Then, we generate separate ARDs using the {cards} package for the different sections of the AET02 table and compare them as subsets. Note: If your table does not have an “overall” column, you can use the ARD creation steps at the bottom of the page using primarily ard_categorical(). ard_hierarchical() is useful here to calculate the statistics for the overall column and allows for better filtering using the “context” column.\n\nlibrary(cards)\nlibrary(dplyr)\n\n# data pre-processing\nadae &lt;- syn_data$adae\nadsl &lt;- syn_data$adsl\n\n# Keep only 1 record per patient\nadae_one_sub &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\")]))\n\n# Keep only 1 record per patient for each AEBODSYS\nadae_one_sub_aebod &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\", \"AEBODSYS\")]))\n\n# ----- ARDS -----\n# Total number of patients with at least one adverse event  \ntot_pat_ae &lt;- ard_stack_hierarchical(\n  data = adae_one_sub,\n  id = \"USUBJID\",\n  variables = c(SAFFL),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\"),\n  overall = TRUE) |&gt;\n  dplyr::filter(context == \"hierarchical\") |&gt; ## removing univariate analysis\n  shuffle_ard(trim = FALSE) |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_))) # convert list to numeric\n\n# Total number of AEs \ntot_ae &lt;- ard_stack_hierarchical_count(\n  data = adae,\n  variables = c(SAFFL),\n  denominator = adsl,\n  by = ARM,\n  overall = TRUE) |&gt;\n  dplyr::filter(context == \"hierarchical_count\") |&gt; ## removing univariate analysis\n  dplyr::mutate(\n    # convert lists to character and numeric\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)), \n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n# Total number of patients with at least one adverse event within each AEBODSYS\ntot_pat_ae_aebod &lt;- ard_stack_hierarchical(\n  id = \"USUBJID\",\n  data = adae_one_sub_aebod,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  overall = TRUE,\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt;\n  dplyr::filter(context == \"hierarchical\") |&gt;  ## removing univariate analysis\n  dplyr::mutate(\n    # convert lists to character and numeric\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\n# Total number of AEs for each AEBODSYS\ntot_ae_aebod &lt;- ard_stack_hierarchical_count(\n  data = adae,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  denominator = adsl,\n  overall = TRUE) |&gt; \n  shuffle_ard(trim = FALSE) |&gt;\n  dplyr::filter(context == \"hierarchical_count\") |&gt; ## removing univariate analysis\n  dplyr::mutate(\n    # convert lists to character and numeric\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    ARM = purrr::map_chr(ARM, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\n# Count and Percent for each AEDECOD within each AEBODSYS\nae_n_p_aedecod &lt;- ard_stack_hierarchical(\n  data = adae,\n  id = \"USUBJID\",\n  variables = c(AEBODSYS, AEDECOD),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\"),\n  overall = TRUE) |&gt; \n  shuffle_ard(trim = FALSE) |&gt; \n  dplyr::filter(context == \"hierarchical\", \n                variable == \"AEDECOD\") |&gt; \n  dplyr::mutate(\n    # convert list numeric\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n\n\n\nWe’ll modify the rtables result to closely match the ARD result:\n\nRename “group2_level” to ARM\nRemove any columns that aren’t in the ARD result (stat_name is being removed as it is a blank column)\n\n\n\nShow the code\nrtables_result &lt;- rtables_result %&gt;%\n  dplyr::rename(ARM = group2_level)%&gt;%\n  dplyr::select(-c(\"stat_name\", \"group2\"))\n\nhead(rtables_result, n=10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroup1\ngroup1_level\nARM\nvariable\nvariable_level\nvariable_label\nstat\n\n\n\n\nNA\nNA\nA: Drug X\nUSUBJID\nunique\nTotal number of patients with at least one adverse event\n13.0000000\n\n\nNA\nNA\nA: Drug X\nUSUBJID\nunique\nTotal number of patients with at least one adverse event\n0.8666667\n\n\nNA\nNA\nA: Drug X\nUSUBJID\nnonunique\nOverall total number of events\n58.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEBODSYS\nunique\nTotal number of patients with at least one adverse event\n7.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEBODSYS\nunique\nTotal number of patients with at least one adverse event\n0.4666667\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEBODSYS\nnonunique\nTotal number of events\n8.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.1\ndcd A.1.1.1.1\n3.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.1\ndcd A.1.1.1.1\n0.2000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.2\ndcd A.1.1.1.2\n5.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.2\ndcd A.1.1.1.2\n0.3333333\n\n\n\n\n\n\nBecause the subsets of AET02 table are already separated in the ARDs, we can subset the {rtables} result equally to create a clean comparison.\n\n\n\ntot_pat_ae &lt;- tot_pat_ae |&gt; dplyr::select(c(\"ARM\", \"stat\"))\n\ntot_pat_ae_rtables &lt;- rtables_result %&gt;%\n  filter(variable_label == \"Total number of patients with at least one adverse event\" & variable == \"USUBJID\") |&gt;\n  dplyr::select(\"ARM\", \"stat\")\n\nlibrary(diffdf)\ndiffdf(tot_pat_ae, tot_pat_ae_rtables, keys = c(\"ARM\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\ntot_ae &lt;- tot_ae |&gt;   \n  dplyr::rename(ARM = group1_level) |&gt;\n  dplyr::mutate(ARM = ifelse(is.na(ARM), \"Overall ARM\", ARM))|&gt;\n  dplyr::select(c(\"ARM\", \"stat\"))\n\ntot_ae_rtables &lt;- rtables_result %&gt;%\n  filter(variable == \"USUBJID\" & variable_label == \"Overall total number of events\")|&gt;\n  dplyr::select(\"ARM\", \"stat\")\n\ndiffdf(tot_ae, tot_ae_rtables, keys = c(\"ARM\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\ntot_pat_ae_aebod &lt;- tot_pat_ae_aebod %&gt;%\n  dplyr::rename(ARM = group1_level) |&gt;\n  dplyr::mutate(ARM = ifelse(is.na(ARM), \"Overall ARM\", ARM))|&gt;\n  dplyr::select(c(\"ARM\", \"variable\", \"variable_level\", \"stat\")) |&gt;\n  dplyr::mutate(\n    ARM = purrr::map_chr(ARM, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    variable_level = purrr::map_chr(variable_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\ntot_pat_ae_aebod_rtables &lt;- rtables_result %&gt;%\n   filter(variable_level == \"unique\" & variable_label == \"Total number of patients with at least one adverse event\" & group1 == \"AEBODSYS\") |&gt;\n  dplyr::select(c(\"ARM\", \"variable\", \"stat\", \"group1_level\")) |&gt;\n  dplyr::rename(variable_level = group1_level)\n\ndiffdf(tot_pat_ae_aebod, tot_pat_ae_aebod_rtables, keys = c(\"ARM\", \"variable_level\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\ntot_ae_aebod &lt;- tot_ae_aebod |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\ntot_ae_aebod_rtables &lt;- rtables_result %&gt;%\n  filter(variable_label == \"Total number of events\") |&gt;\n    dplyr::rename(label = group1_level) |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\ndiffdf(tot_ae_aebod, tot_ae_aebod_rtables, keys = c(\"ARM\", \"label\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\nae_n_p_aedecod &lt;- ae_n_p_aedecod |&gt;\n  dplyr::mutate(ARM = ifelse(is.na(ARM), \"Overall ARM\", ARM)) |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\nae_n_p_aedecod_rtables &lt;- rtables_result %&gt;%\n  filter(variable == \"AEDECOD\") |&gt;\n    dplyr::rename(label = variable_label) |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\ndiffdf(ae_n_p_aedecod, ae_n_p_aedecod_rtables, keys = c(\"ARM\", \"label\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\n\nlibrary(cards)\nlibrary(dplyr)\n\n# some data pre-processing\nadae &lt;- syn_data$adae\nadsl &lt;- syn_data$adsl\n\n# Keep only 1 record per patient\nadae_one_sub &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\")]))\n\n# Keep only 1 record per patient for each AEBODSYS\nadae_one_sub_aebod &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\", \"AEBODSYS\")]))\n\n\n# ----- ARDS -----\n# Total number of patients with at least one adverse event  ## removing univariate analysis\ntot_pat_ae &lt;- ard_categorical(\n  data = adae_one_sub,\n  variables = c(SAFFL),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n# Total number of AEs \ntot_ae &lt;- ard_categorical(\n  data = adae,\n  variables = c(SAFFL),\n  denominator = adsl,\n  by = ARM,\n  statistic = everything() ~ c(\"n\")) |&gt;\n  dplyr::mutate(\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n# Total number of patients with at least one adverse event within each AEBODSYS\ntot_pat_ae_aebod &lt;- ard_categorical(\n  data = adae_one_sub_aebod,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\n# Total number of AEs for each AEBODSYS\ntot_ae_aebod &lt;- ard_categorical(\n  data = adae,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\")) |&gt; \n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n  \n# Count and Percent for each AEDECOD within each AEBODSYS\nae_n_p_aedecod &lt;- ard_stack_hierarchical(\n  data = adae,\n  id = \"USUBJID\",\n  variables = c(AEBODSYS, AEDECOD),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt; \n  dplyr::filter(context == \"hierarchical\", \n                variable == \"AEDECOD\") |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))",
    "crumbs": [
      "Adverse Events Table"
    ]
  },
  {
    "objectID": "quarto/02-QC-AET02.html#adverse-events-aet02-qc-workflow",
    "href": "quarto/02-QC-AET02.html#adverse-events-aet02-qc-workflow",
    "title": "QCing Adverse Events (AET02)",
    "section": "",
    "text": "Show the code\nlibrary(chevron)\n\ntlg_aet02 &lt;- chevron:: aet02_main(syn_data, arm_var = \"ARM\", lbl_overall = \"Overall ARM\")\nhead(tlg_aet02, n=15) #truncated preview\n\n\n                                                             A: Drug X    B: Placebo   C: Combination   Overall ARM\n                                                               (N=15)       (N=15)         (N=15)         (N=45)   \n———————————————————————————————————————————————————————————————————————————————————————————————————————————————————\nTotal number of patients with at least one adverse event     13 (86.7%)   14 (93.3%)     15 (100%)      42 (93.3%) \nOverall total number of events                                   58           59             99             216    \ncl A.1                                                                                                             \n  Total number of patients with at least one adverse event   7 (46.7%)    6 (40.0%)      10 (66.7%)     23 (51.1%) \n  Total number of events                                         8            11             16             35     \n  dcd A.1.1.1.1                                              3 (20.0%)     1 (6.7%)      6 (40.0%)      10 (22.2%) \n  dcd A.1.1.1.2                                              5 (33.3%)    6 (40.0%)      6 (40.0%)      17 (37.8%) \ncl B.1                                                                                                             \n  Total number of patients with at least one adverse event   5 (33.3%)    6 (40.0%)      8 (53.3%)      19 (42.2%) \n  Total number of events                                         6            6              12             24     \n  dcd B.1.1.1.1                                              5 (33.3%)    6 (40.0%)      8 (53.3%)      19 (42.2%) \ncl B.2                                                                                                             \n  Total number of patients with at least one adverse event   11 (73.3%)   8 (53.3%)      10 (66.7%)     29 (64.4%) \n  Total number of events                                         18           15             20             53     \n  dcd B.2.1.2.1                                              5 (33.3%)    6 (40.0%)      5 (33.3%)      16 (35.6%) \n\n\n\n\n\nA {rtables} based output can be flattened into a data.frame using the as_results_df() function from the {rtables} package. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards} package. Setting the add_tbl_str_decimals to FALSE will not return a column with the statistic as a formatted string. We also include a step to remove the “label” attribute for the statistics. The diffdf() function is sensitive to attribute mismatch, so we will remove them (set to NULL) to match the ARD results exactly.\n\nrtables_result &lt;- rtables::as_result_df(tlg_aet02, make_ard = TRUE, add_tbl_str_decimals = FALSE)\nattr(rtables_result$stat, \"label\") &lt;- NULL\n\nrtables_result[1:6, -c(1:2, 7,8)]\n\n\n\n\n\ngroup2\ngroup2_level\nvariable\nvariable_level\nstat\n\n\n\n\nARM\nA: Drug X\nUSUBJID\nunique\n13.0000000\n\n\nARM\nA: Drug X\nUSUBJID\nunique\n0.8666667\n\n\nARM\nA: Drug X\nUSUBJID\nnonunique\n58.0000000\n\n\nARM\nA: Drug X\nAEBODSYS\nunique\n7.0000000\n\n\nARM\nA: Drug X\nAEBODSYS\nunique\n0.4666667\n\n\nARM\nA: Drug X\nAEBODSYS\nnonunique\n8.0000000\n\n\n\n\n\n\n\n\n\nIn the code below, we perform different data pre-processing for the different ARDs we want to create. Then, we generate separate ARDs using the {cards} package for the different sections of the AET02 table and compare them as subsets. Note: If your table does not have an “overall” column, you can use the ARD creation steps at the bottom of the page using primarily ard_categorical(). ard_hierarchical() is useful here to calculate the statistics for the overall column and allows for better filtering using the “context” column.\n\nlibrary(cards)\nlibrary(dplyr)\n\n# data pre-processing\nadae &lt;- syn_data$adae\nadsl &lt;- syn_data$adsl\n\n# Keep only 1 record per patient\nadae_one_sub &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\")]))\n\n# Keep only 1 record per patient for each AEBODSYS\nadae_one_sub_aebod &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\", \"AEBODSYS\")]))\n\n# ----- ARDS -----\n# Total number of patients with at least one adverse event  \ntot_pat_ae &lt;- ard_stack_hierarchical(\n  data = adae_one_sub,\n  id = \"USUBJID\",\n  variables = c(SAFFL),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\"),\n  overall = TRUE) |&gt;\n  dplyr::filter(context == \"hierarchical\") |&gt; ## removing univariate analysis\n  shuffle_ard(trim = FALSE) |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_))) # convert list to numeric\n\n# Total number of AEs \ntot_ae &lt;- ard_stack_hierarchical_count(\n  data = adae,\n  variables = c(SAFFL),\n  denominator = adsl,\n  by = ARM,\n  overall = TRUE) |&gt;\n  dplyr::filter(context == \"hierarchical_count\") |&gt; ## removing univariate analysis\n  dplyr::mutate(\n    # convert lists to character and numeric\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)), \n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n# Total number of patients with at least one adverse event within each AEBODSYS\ntot_pat_ae_aebod &lt;- ard_stack_hierarchical(\n  id = \"USUBJID\",\n  data = adae_one_sub_aebod,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  overall = TRUE,\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt;\n  dplyr::filter(context == \"hierarchical\") |&gt;  ## removing univariate analysis\n  dplyr::mutate(\n    # convert lists to character and numeric\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\n# Total number of AEs for each AEBODSYS\ntot_ae_aebod &lt;- ard_stack_hierarchical_count(\n  data = adae,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  denominator = adsl,\n  overall = TRUE) |&gt; \n  shuffle_ard(trim = FALSE) |&gt;\n  dplyr::filter(context == \"hierarchical_count\") |&gt; ## removing univariate analysis\n  dplyr::mutate(\n    # convert lists to character and numeric\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    ARM = purrr::map_chr(ARM, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\n# Count and Percent for each AEDECOD within each AEBODSYS\nae_n_p_aedecod &lt;- ard_stack_hierarchical(\n  data = adae,\n  id = \"USUBJID\",\n  variables = c(AEBODSYS, AEDECOD),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\"),\n  overall = TRUE) |&gt; \n  shuffle_ard(trim = FALSE) |&gt; \n  dplyr::filter(context == \"hierarchical\", \n                variable == \"AEDECOD\") |&gt; \n  dplyr::mutate(\n    # convert list numeric\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n\n\n\nWe’ll modify the rtables result to closely match the ARD result:\n\nRename “group2_level” to ARM\nRemove any columns that aren’t in the ARD result (stat_name is being removed as it is a blank column)\n\n\n\nShow the code\nrtables_result &lt;- rtables_result %&gt;%\n  dplyr::rename(ARM = group2_level)%&gt;%\n  dplyr::select(-c(\"stat_name\", \"group2\"))\n\nhead(rtables_result, n=10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroup1\ngroup1_level\nARM\nvariable\nvariable_level\nvariable_label\nstat\n\n\n\n\nNA\nNA\nA: Drug X\nUSUBJID\nunique\nTotal number of patients with at least one adverse event\n13.0000000\n\n\nNA\nNA\nA: Drug X\nUSUBJID\nunique\nTotal number of patients with at least one adverse event\n0.8666667\n\n\nNA\nNA\nA: Drug X\nUSUBJID\nnonunique\nOverall total number of events\n58.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEBODSYS\nunique\nTotal number of patients with at least one adverse event\n7.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEBODSYS\nunique\nTotal number of patients with at least one adverse event\n0.4666667\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEBODSYS\nnonunique\nTotal number of events\n8.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.1\ndcd A.1.1.1.1\n3.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.1\ndcd A.1.1.1.1\n0.2000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.2\ndcd A.1.1.1.2\n5.0000000\n\n\nAEBODSYS\ncl A.1\nA: Drug X\nAEDECOD\ndcd A.1.1.1.2\ndcd A.1.1.1.2\n0.3333333\n\n\n\n\n\n\nBecause the subsets of AET02 table are already separated in the ARDs, we can subset the {rtables} result equally to create a clean comparison.\n\n\n\ntot_pat_ae &lt;- tot_pat_ae |&gt; dplyr::select(c(\"ARM\", \"stat\"))\n\ntot_pat_ae_rtables &lt;- rtables_result %&gt;%\n  filter(variable_label == \"Total number of patients with at least one adverse event\" & variable == \"USUBJID\") |&gt;\n  dplyr::select(\"ARM\", \"stat\")\n\nlibrary(diffdf)\ndiffdf(tot_pat_ae, tot_pat_ae_rtables, keys = c(\"ARM\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\ntot_ae &lt;- tot_ae |&gt;   \n  dplyr::rename(ARM = group1_level) |&gt;\n  dplyr::mutate(ARM = ifelse(is.na(ARM), \"Overall ARM\", ARM))|&gt;\n  dplyr::select(c(\"ARM\", \"stat\"))\n\ntot_ae_rtables &lt;- rtables_result %&gt;%\n  filter(variable == \"USUBJID\" & variable_label == \"Overall total number of events\")|&gt;\n  dplyr::select(\"ARM\", \"stat\")\n\ndiffdf(tot_ae, tot_ae_rtables, keys = c(\"ARM\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\ntot_pat_ae_aebod &lt;- tot_pat_ae_aebod %&gt;%\n  dplyr::rename(ARM = group1_level) |&gt;\n  dplyr::mutate(ARM = ifelse(is.na(ARM), \"Overall ARM\", ARM))|&gt;\n  dplyr::select(c(\"ARM\", \"variable\", \"variable_level\", \"stat\")) |&gt;\n  dplyr::mutate(\n    ARM = purrr::map_chr(ARM, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    variable_level = purrr::map_chr(variable_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\ntot_pat_ae_aebod_rtables &lt;- rtables_result %&gt;%\n   filter(variable_level == \"unique\" & variable_label == \"Total number of patients with at least one adverse event\" & group1 == \"AEBODSYS\") |&gt;\n  dplyr::select(c(\"ARM\", \"variable\", \"stat\", \"group1_level\")) |&gt;\n  dplyr::rename(variable_level = group1_level)\n\ndiffdf(tot_pat_ae_aebod, tot_pat_ae_aebod_rtables, keys = c(\"ARM\", \"variable_level\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\ntot_ae_aebod &lt;- tot_ae_aebod |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\ntot_ae_aebod_rtables &lt;- rtables_result %&gt;%\n  filter(variable_label == \"Total number of events\") |&gt;\n    dplyr::rename(label = group1_level) |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\ndiffdf(tot_ae_aebod, tot_ae_aebod_rtables, keys = c(\"ARM\", \"label\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\nae_n_p_aedecod &lt;- ae_n_p_aedecod |&gt;\n  dplyr::mutate(ARM = ifelse(is.na(ARM), \"Overall ARM\", ARM)) |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\nae_n_p_aedecod_rtables &lt;- rtables_result %&gt;%\n  filter(variable == \"AEDECOD\") |&gt;\n    dplyr::rename(label = variable_label) |&gt;\n  dplyr::select(c(\"ARM\", \"label\", \"stat\"))\n\ndiffdf(ae_n_p_aedecod, ae_n_p_aedecod_rtables, keys = c(\"ARM\", \"label\", \"stat\"))\n\nNo issues were found!\n\n\n\n\n\n\n\nlibrary(cards)\nlibrary(dplyr)\n\n# some data pre-processing\nadae &lt;- syn_data$adae\nadsl &lt;- syn_data$adsl\n\n# Keep only 1 record per patient\nadae_one_sub &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\")]))\n\n# Keep only 1 record per patient for each AEBODSYS\nadae_one_sub_aebod &lt;- adae %&gt;% \n  filter(!duplicated(adae[c(\"USUBJID\", \"AEBODSYS\")]))\n\n\n# ----- ARDS -----\n# Total number of patients with at least one adverse event  ## removing univariate analysis\ntot_pat_ae &lt;- ard_categorical(\n  data = adae_one_sub,\n  variables = c(SAFFL),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n# Total number of AEs \ntot_ae &lt;- ard_categorical(\n  data = adae,\n  variables = c(SAFFL),\n  denominator = adsl,\n  by = ARM,\n  statistic = everything() ~ c(\"n\")) |&gt;\n  dplyr::mutate(\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n\n# Total number of patients with at least one adverse event within each AEBODSYS\ntot_pat_ae_aebod &lt;- ard_categorical(\n  data = adae_one_sub_aebod,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)))\n\n# Total number of AEs for each AEBODSYS\ntot_ae_aebod &lt;- ard_categorical(\n  data = adae,\n  variables = c(AEBODSYS),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\")) |&gt; \n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))\n  \n# Count and Percent for each AEDECOD within each AEBODSYS\nae_n_p_aedecod &lt;- ard_stack_hierarchical(\n  data = adae,\n  id = \"USUBJID\",\n  variables = c(AEBODSYS, AEDECOD),\n  by = c(ARM),\n  denominator = adsl,\n  statistic = everything() ~ c(\"n\", \"p\")) |&gt; \n  dplyr::filter(context == \"hierarchical\", \n                variable == \"AEDECOD\") |&gt;\n  dplyr::mutate(\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)))",
    "crumbs": [
      "Adverse Events Table"
    ]
  },
  {
    "objectID": "quarto/03-QC-LBT01.html",
    "href": "quarto/03-QC-LBT01.html",
    "title": "QCing Laboratory Test Results and Change from Baseline by Visit (LBT01)",
    "section": "",
    "text": "Using the lbt01_main() function from the {chevron} package to generate a Lab Results Table. We’ll add an overall column to walk through the QCing steps if your table has one.\n\n\nShow the code\nlibrary(chevron)\n\n# Create a table using the chevron package \ntlg_lbt01 &lt;- chevron::lbt01_main(syn_data, lbl_overall = \"Overall ARM\")\nhead(tlg_lbt01, n = 15) #truncated display\n\n\n                                                          A: Drug X                                        B: Placebo                                      C: Combination                                     Overall ARM                  \n                                       Analysis Value    Absolute Change from Baseline   Analysis Value    Absolute Change from Baseline   Analysis Value   Absolute Change from Baseline   Analysis Value    Absolute Change from Baseline\n                                           (N=15)                   (N=15)                   (N=15)                   (N=15)                   (N=15)                  (N=15)                   (N=45)                   (N=45)            \n———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\nAlanine Aminotransferase Measurement                                                                                                                                                                                                       \n  SCREENING                                                                                                                                                                                                                                \n    n                                        15                        0                       15                        0                       15                       0                       45                        0              \n    Mean (SD)                          15.746 (7.382)               NE (NE)              21.443 (9.716)               NE (NE)              21.234 (6.314)              NE (NE)              19.474 (8.196)               NE (NE)           \n    Median                                 15.466                     NE                     23.567                     NE                     22.179                    NE                     21.295                     NE              \n    Min - Max                           3.29 - 29.00                NE - NE               1.89 - 33.95                NE - NE               9.64 - 31.59               NE - NE               1.89 - 33.95                NE - NE           \n  BASELINE                                                                                                                                                                                                                                 \n    n                                        15                                                15                                                15                                               45                                       \n    Mean (SD)                          18.655 (12.455)                                   16.835 (11.080)                                   22.385 (9.452)                                   19.292 (11.059)                                \n    Median                                 16.040                                            17.453                                            25.250                                           18.691                                     \n    Min - Max                           2.43 - 44.06                                      1.48 - 31.99                                      0.57 - 37.23                                     0.57 - 44.06                                  \n  WEEK 1 DAY 8                                                                                                                                                                                                                             \n    n                                        15                       15                       15                       15                       15                      15                       45                       45              \n    Mean (SD)                          16.308 (10.850)          -2.348 (17.558)          22.055 (7.537)           5.220 (16.359)           19.574 (9.876)          -2.811 (10.902)          19.313 (9.604)           0.020 (15.327)        \n    Median                                 14.664                   -5.369                   22.476                    7.252                   19.425                  -0.995                   19.198                   -0.995            \n\n\n\n\n\nA {rtables} based output can be flattened into a data frame using the as_results_df() function from the {rtables package}. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards}/{cardx} package. Setting the add_tbl_str_decimals to FALSE will not return a column with the statistic as a formatted string.\n\nrtables_result &lt;- rtables::as_result_df(tlg_lbt01, make_ard = TRUE, add_tbl_str_decimals = FALSE)\n\n\n\n\nUsing the ard_continuous function, we will compute the lab results statistics. Notice how there are multiple variables specified by by: observations will be grouped in that sequence before calculating the statistics for the variables listed in variables. If your table is pruning unobserved levels during calculation, the by parameter should be replaced with the strata parameter (more detail described in the documentation here).\nTo calculate the statistics for the overall column, the code should look similar to the prior calculation with the “ARM” variable removed from the by (or strata) parameter (indicating the data is not stratified by “ARM”).\nWe’ll keep the stats for the overall column in a separate data.frame to generalize this workflow.\n\nlibrary(cards)\nlibrary(dplyr)\n\nadlb &lt;- chevron::syn_data$adlb\n\nard_result &lt;- ard_continuous(adlb, \n                             by = c(ACTARM, PARAMCD, AVISIT), \n                             variables = c(AVAL, CHG), \n                             statistic = \n                               list(everything() ~ continuous_summary_fns(c(\"N\", \"mean\", \"sd\", \"median\", \"min\", \"max\"))))\n\n# calculate overall statistics\nard_overall &lt;- ard_continuous(adlb, \n                             by = c(PARAMCD, AVISIT), # note arm var is removed\n                             variables = c(AVAL, CHG), \n                             statistic = \n                               list(everything() ~ continuous_summary_fns(c(\"N\", \"mean\", \"sd\", \"median\", \"min\", \"max\"))))\n\n\n\n\n\n\nSome reformatting is required to ensure the resulting data.frames are compatible. Most of the reformatting is adjusting the column names to match that of the ARD result.\n\nrename group1 and group1_level, ARM and ARM levels accordingly.\nrename group2 and group2_level, PARAMCD and PARAMCD levels accordingly.\nrename group3 and group3_level, AVISIT and AVISIT levels accordingly.\nrecode stat n value to N to match ARD\nSelect columns relevant to comparison\n\nWe’ll also separate the statistics related to the overall ARM to match the ard_overall object.\n\nrtables_result &lt;- rtables_result |&gt;\n  dplyr::mutate(stat_name = dplyr::recode(stat_name, \"n\" = \"N\"),\n                group4_level = dplyr::recode(group4_level, \n                                             \"Analysis Value\" = \"AVAL\",\n                                             \"Absolute Change from Baseline\" = \"CHG\")) |&gt;\n  dplyr::rename(group1 = group3,\n                group1_level = group3_level,\n                group2 = group1,\n                group2_level = group1_level,\n                group3 = group2,\n                group3_level = group2_level,\n                variable = group4_level,\n                # giving a dummy name for this column so it doesn't interfere with the column renaming\n                val = variable) |&gt;\n  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat))\n\nrtables_result_overall &lt;- rtables_result |&gt;\n  dplyr::filter(group1_level == \"Overall ARM\")\n\n# remove the overall observations from the results df\nrtables_result &lt;- rtables_result |&gt;\n  dplyr::filter(group1_level != \"Overall ARM\")\n\nBased on dimensions alone - we can see that tables likely generated similar results\n\n\nShow the code\nprint(\"rtables Dimensions\")\n\n\n[1] \"rtables Dimensions\"\n\n\nShow the code\ndim(rtables_result)\n\n\n[1] 756   9\n\n\nShow the code\nprint(\"ARD Dimensions\")\n\n\n[1] \"ARD Dimensions\"\n\n\nShow the code\ndim(ard_result)\n\n\n[1] 756  14\n\n\n\n\nWe’ll also need some format adjustments for the ARD object. Primarily, converting lists to vectors (character or numeric) to match the rtables_result format. Not doing so will result in an incompatible comparison errors in diffdf().\n\nSelect columns relevant to comparison\nConvert any list columns to character and numeric\nConvert any NaN stats to NA to match {rtables}\n\n\n\nShow the code\nard_result &lt;- ard_result |&gt;\n  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat)) |&gt;\n  dplyr::mutate(\n  group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n  stat = dplyr::recode(stat, `NaN` = NA_real_))\n\n# to the overall ard_result, rename the cols to match the rtables df\n\nard_overall &lt;- ard_overall |&gt;\n  dplyr::rename(group2 = group1,\n                group2_level = group1_level,\n                group3 = group2,\n                group3_level = group2_level) |&gt;\n   dplyr::mutate(group1 = \"ACTARM\",\n                 group1_level = \"Overall ARM\",\n  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n  stat = dplyr::recode(stat, `NaN` = NA_real_)) |&gt;\n  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat))\n\n\n\n\n\n\nUse the diffdf package to compare the results.\n\n\nShow the code\nlibrary(diffdf)\n\ndiffdf(ard_result, \n       rtables_result,\n       keys = c(\"group1\", \"group1_level\", \"group2\", \"group2_level\", \"group3\", \"group3_level\", \"variable\", \"stat_name\", \"stat\"),\n       suppress_warnings = TRUE)\n\n\nNo issues were found!\n\n\n\n\n\n\nShow the code\ndiffdf(ard_overall, \n       rtables_result_overall, \n       keys = c(\"group1\", \"group1_level\", \"group2\", \"group2_level\", \"group3\", \"group3_level\", \"variable\", \"stat_name\", \"stat\"),\n       suppress_warnings = TRUE)\n\n\nNo issues were found!",
    "crumbs": [
      "Lab Results Table"
    ]
  },
  {
    "objectID": "quarto/03-QC-LBT01.html#laboratory-test-results-and-change-from-baseline-by-visit-lbt01-qc-workflow",
    "href": "quarto/03-QC-LBT01.html#laboratory-test-results-and-change-from-baseline-by-visit-lbt01-qc-workflow",
    "title": "QCing Laboratory Test Results and Change from Baseline by Visit (LBT01)",
    "section": "",
    "text": "Using the lbt01_main() function from the {chevron} package to generate a Lab Results Table. We’ll add an overall column to walk through the QCing steps if your table has one.\n\n\nShow the code\nlibrary(chevron)\n\n# Create a table using the chevron package \ntlg_lbt01 &lt;- chevron::lbt01_main(syn_data, lbl_overall = \"Overall ARM\")\nhead(tlg_lbt01, n = 15) #truncated display\n\n\n                                                          A: Drug X                                        B: Placebo                                      C: Combination                                     Overall ARM                  \n                                       Analysis Value    Absolute Change from Baseline   Analysis Value    Absolute Change from Baseline   Analysis Value   Absolute Change from Baseline   Analysis Value    Absolute Change from Baseline\n                                           (N=15)                   (N=15)                   (N=15)                   (N=15)                   (N=15)                  (N=15)                   (N=45)                   (N=45)            \n———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\nAlanine Aminotransferase Measurement                                                                                                                                                                                                       \n  SCREENING                                                                                                                                                                                                                                \n    n                                        15                        0                       15                        0                       15                       0                       45                        0              \n    Mean (SD)                          15.746 (7.382)               NE (NE)              21.443 (9.716)               NE (NE)              21.234 (6.314)              NE (NE)              19.474 (8.196)               NE (NE)           \n    Median                                 15.466                     NE                     23.567                     NE                     22.179                    NE                     21.295                     NE              \n    Min - Max                           3.29 - 29.00                NE - NE               1.89 - 33.95                NE - NE               9.64 - 31.59               NE - NE               1.89 - 33.95                NE - NE           \n  BASELINE                                                                                                                                                                                                                                 \n    n                                        15                                                15                                                15                                               45                                       \n    Mean (SD)                          18.655 (12.455)                                   16.835 (11.080)                                   22.385 (9.452)                                   19.292 (11.059)                                \n    Median                                 16.040                                            17.453                                            25.250                                           18.691                                     \n    Min - Max                           2.43 - 44.06                                      1.48 - 31.99                                      0.57 - 37.23                                     0.57 - 44.06                                  \n  WEEK 1 DAY 8                                                                                                                                                                                                                             \n    n                                        15                       15                       15                       15                       15                      15                       45                       45              \n    Mean (SD)                          16.308 (10.850)          -2.348 (17.558)          22.055 (7.537)           5.220 (16.359)           19.574 (9.876)          -2.811 (10.902)          19.313 (9.604)           0.020 (15.327)        \n    Median                                 14.664                   -5.369                   22.476                    7.252                   19.425                  -0.995                   19.198                   -0.995            \n\n\n\n\n\nA {rtables} based output can be flattened into a data frame using the as_results_df() function from the {rtables package}. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards}/{cardx} package. Setting the add_tbl_str_decimals to FALSE will not return a column with the statistic as a formatted string.\n\nrtables_result &lt;- rtables::as_result_df(tlg_lbt01, make_ard = TRUE, add_tbl_str_decimals = FALSE)\n\n\n\n\nUsing the ard_continuous function, we will compute the lab results statistics. Notice how there are multiple variables specified by by: observations will be grouped in that sequence before calculating the statistics for the variables listed in variables. If your table is pruning unobserved levels during calculation, the by parameter should be replaced with the strata parameter (more detail described in the documentation here).\nTo calculate the statistics for the overall column, the code should look similar to the prior calculation with the “ARM” variable removed from the by (or strata) parameter (indicating the data is not stratified by “ARM”).\nWe’ll keep the stats for the overall column in a separate data.frame to generalize this workflow.\n\nlibrary(cards)\nlibrary(dplyr)\n\nadlb &lt;- chevron::syn_data$adlb\n\nard_result &lt;- ard_continuous(adlb, \n                             by = c(ACTARM, PARAMCD, AVISIT), \n                             variables = c(AVAL, CHG), \n                             statistic = \n                               list(everything() ~ continuous_summary_fns(c(\"N\", \"mean\", \"sd\", \"median\", \"min\", \"max\"))))\n\n# calculate overall statistics\nard_overall &lt;- ard_continuous(adlb, \n                             by = c(PARAMCD, AVISIT), # note arm var is removed\n                             variables = c(AVAL, CHG), \n                             statistic = \n                               list(everything() ~ continuous_summary_fns(c(\"N\", \"mean\", \"sd\", \"median\", \"min\", \"max\"))))\n\n\n\n\n\n\nSome reformatting is required to ensure the resulting data.frames are compatible. Most of the reformatting is adjusting the column names to match that of the ARD result.\n\nrename group1 and group1_level, ARM and ARM levels accordingly.\nrename group2 and group2_level, PARAMCD and PARAMCD levels accordingly.\nrename group3 and group3_level, AVISIT and AVISIT levels accordingly.\nrecode stat n value to N to match ARD\nSelect columns relevant to comparison\n\nWe’ll also separate the statistics related to the overall ARM to match the ard_overall object.\n\nrtables_result &lt;- rtables_result |&gt;\n  dplyr::mutate(stat_name = dplyr::recode(stat_name, \"n\" = \"N\"),\n                group4_level = dplyr::recode(group4_level, \n                                             \"Analysis Value\" = \"AVAL\",\n                                             \"Absolute Change from Baseline\" = \"CHG\")) |&gt;\n  dplyr::rename(group1 = group3,\n                group1_level = group3_level,\n                group2 = group1,\n                group2_level = group1_level,\n                group3 = group2,\n                group3_level = group2_level,\n                variable = group4_level,\n                # giving a dummy name for this column so it doesn't interfere with the column renaming\n                val = variable) |&gt;\n  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat))\n\nrtables_result_overall &lt;- rtables_result |&gt;\n  dplyr::filter(group1_level == \"Overall ARM\")\n\n# remove the overall observations from the results df\nrtables_result &lt;- rtables_result |&gt;\n  dplyr::filter(group1_level != \"Overall ARM\")\n\nBased on dimensions alone - we can see that tables likely generated similar results\n\n\nShow the code\nprint(\"rtables Dimensions\")\n\n\n[1] \"rtables Dimensions\"\n\n\nShow the code\ndim(rtables_result)\n\n\n[1] 756   9\n\n\nShow the code\nprint(\"ARD Dimensions\")\n\n\n[1] \"ARD Dimensions\"\n\n\nShow the code\ndim(ard_result)\n\n\n[1] 756  14\n\n\n\n\nWe’ll also need some format adjustments for the ARD object. Primarily, converting lists to vectors (character or numeric) to match the rtables_result format. Not doing so will result in an incompatible comparison errors in diffdf().\n\nSelect columns relevant to comparison\nConvert any list columns to character and numeric\nConvert any NaN stats to NA to match {rtables}\n\n\n\nShow the code\nard_result &lt;- ard_result |&gt;\n  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat)) |&gt;\n  dplyr::mutate(\n  group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n  stat = dplyr::recode(stat, `NaN` = NA_real_))\n\n# to the overall ard_result, rename the cols to match the rtables df\n\nard_overall &lt;- ard_overall |&gt;\n  dplyr::rename(group2 = group1,\n                group2_level = group1_level,\n                group3 = group2,\n                group3_level = group2_level) |&gt;\n   dplyr::mutate(group1 = \"ACTARM\",\n                 group1_level = \"Overall ARM\",\n  group2_level = purrr::map_chr(group2_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  group3_level = purrr::map_chr(group3_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n  stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n  stat = dplyr::recode(stat, `NaN` = NA_real_)) |&gt;\n  dplyr::select(c(group1, group1_level, group2, group2_level, group3, group3_level, variable, stat_name, stat))\n\n\n\n\n\n\nUse the diffdf package to compare the results.\n\n\nShow the code\nlibrary(diffdf)\n\ndiffdf(ard_result, \n       rtables_result,\n       keys = c(\"group1\", \"group1_level\", \"group2\", \"group2_level\", \"group3\", \"group3_level\", \"variable\", \"stat_name\", \"stat\"),\n       suppress_warnings = TRUE)\n\n\nNo issues were found!\n\n\n\n\n\n\nShow the code\ndiffdf(ard_overall, \n       rtables_result_overall, \n       keys = c(\"group1\", \"group1_level\", \"group2\", \"group2_level\", \"group3\", \"group3_level\", \"variable\", \"stat_name\", \"stat\"),\n       suppress_warnings = TRUE)\n\n\nNo issues were found!",
    "crumbs": [
      "Lab Results Table"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Utilizing the {cards} and {cardx} packages in the QC Workflow",
    "section": "",
    "text": "Overview\nThe current procedure for generating clinical reporting tables employs NEST packages such as {rtables}, {tern} and {chevron}. These packages create complex table structures and generate statistics that should be programmatically compared.\nIn this document, we will showcase how the {cards} and {cardx} packages can be used to QC common outputs generated using NEST packages.\n {cards}\n {rtables}\n {tern}\n {chevron}",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "QCing with {cards} and {cardx}",
    "section": "",
    "text": "QCing with {cards} and {cardx}\nThis catalog is meant to demo the use of ARD-centric packages within the Quality Control workflow. Verification of statistics generated with NEST packages (such as: {tern}, {rtables}, {chevron}) can be verified by reproducing the tables using Analysis Results Dataset (ARDs)."
  },
  {
    "objectID": "quarto/04-QC-TTET01.html",
    "href": "quarto/04-QC-TTET01.html",
    "title": "QCing Time-to-event Summary (TTET01)",
    "section": "",
    "text": "Show the code\nlibrary(chevron)\n\n# Create a table using the chevron package \nproc_data &lt;- dunlin::log_filter(syn_data, PARAMCD == \"PFS\", \"adtte\")\ntlg_ttet01 &lt;- chevron::run(ttet01, proc_data)\ntlg_ttet01\n\n\n                                      A: Drug X        B: Placebo      C: Combination \n                                        (N=15)           (N=15)            (N=15)     \n  ————————————————————————————————————————————————————————————————————————————————————\n  Patients with event (%)             7 (46.7%)         12 (80%)          8 (53.3%)   \n    Earliest contributing event                                                       \n      Death                               5                11                 7       \n      Disease Progression                 2                 1                 1       \n  Patients without event (%)          8 (53.3%)          3 (20%)          7 (46.7%)   \n  Time to Event (MONTHS)                                                              \n    Median                               8.6               6.2               8.4      \n      95% CI                          (7.3, NE)        (4.8, 7.6)         (7.0, NE)   \n    25% and 75%-ile                    3.8, NE          4.7, 8.4           5.8, NE    \n    Range                           1.2 to 9.5 {1}     0.9 to 9.1      0.9 to 9.5 {1} \n  Unstratified Analysis                                                               \n    p-value (log-rank)                                   0.0973            0.9111     \n    Hazard Ratio                                          2.18              1.06      \n    95% CI                                            (0.85, 5.60)      (0.38, 2.94)  \n  6 MONTHS                                                                            \n    Patients remaining at risk            11                8                11       \n    Event Free Rate (%)                 73.33             53.33             73.33     \n    95% CI                          (50.95, 95.71)   (28.09, 78.58)    (50.95, 95.71) \n    Difference in Event Free Rate                        -20.00             0.00      \n      95% CI                                         (-53.74, 13.74)   (-31.65, 31.65)\n      p-value (Z-test)                                   0.2453            1.0000     \n  ————————————————————————————————————————————————————————————————————————————————————\n\n  {1} - Censored observation: range maximum\n  ————————————————————————————————————————————————————————————————————————————————————\n\n\n\n\n\nA rtables based output can be flattened into a data frame using the as_results_df() function from the rtables package. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards} package.\n\n\nShow the code\nrtables_results &lt;- rtables::as_result_df(tlg_ttet01, make_ard = TRUE, add_tbl_str_decimals = FALSE)\n\n\n\n\n\nUsing the {cards} package, we stack the functions ard_continuous() for the continuous variables and ard_categorical() for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.\nIf any variable manipulation was done to the data prior to running the citril/chevron/tern/rtables commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.\nNote: when a ‘by’ variable is specified in the ard_stack() call, a univariate tabluation is returned. We will have to remove those obervations later in the workflow to create a 1:1 match.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(cards)\nlibrary(cardx)\nlibrary(survival)\n\n\nadtte &lt;- proc_data$adtte |&gt;\n  dplyr::mutate(AVAL = (AVAL/ 30.4375), #convert days to months, this is the same calculation chevron uses.\n                is_event = CNSR == 0, # chevron coding of events\n                is_not_event = CNSR == 1)\n\n# Event Rates\nard_event_rates &lt;- bind_ard(\n  # Patient Event Rates\n  ard_categorical(adtte, strata = c(ARM), variable = c(is_event), statistic = everything()~c(\"n\", \"p\")),\n  # Earliest Contributing Event\n  ard_categorical(adtte |&gt; dplyr::filter(is_event == TRUE), strata = c(ARM), variable = c(EVNTDESC), statistic = everything()~c(\"n\"))\n)\n \n\n# Time to Event\nard_tte &lt;- bind_ard(\n  # calculate median\n  survfit(Surv(AVAL, 1-CNSR) ~ ARM, data = adtte) |&gt;\n  ard_survival_survfit(probs = 0.5), \n  # calculate quantiles\n  survfit(Surv(AVAL, 1-CNSR) ~ ARM, data = adtte) |&gt;\n  ard_survival_survfit(probs = c(0.25, 0.75)) |&gt;\n  filter(stat_name == \"estimate\"),\n  # calculate range\n  ard_continuous(adtte, by = c(ARM), variable = c(AVAL), statistic = ~ continuous_summary_fns(c(\"min\", \"max\")))\n)\n\n# Unstratified Analysis\nard_logrank &lt;-\n  ard_survival_survdiff(\n    formula = Surv(AVAL, CNSR) ~ ARM,\n    data = adtte\n  )\n\n# difference in event free rate\n# event_free &lt;- survfit(Surv_CNSR() ~ ARM, data = adtte) |&gt;\n#   ard_survival_survfit_diff(times = 6) |&gt;\n#   filter(stat_name %in% c(\"estimate\", \"conf.low\", \"conf.high\", \"p.value\"))\n\n\n# unstratified pairwise\n# surv_fit &lt;- coxph(Surv(AVAL, is_event) ~ ARM, data = adtte_f)\nlibrary(cardx)\nlibrary(survival)\n\n  \n# ard_coxph &lt;-\n#   coxph(Surv(AVAL, 1 - CNSR) ~ ARM, data = adtte) |&gt; \n#   ard_regression() |&gt; \n#   dplyr::filter(stat_name %in% c(\"estimate\", \"conf.low\", \"conf.high\"))\n# \n# # 6 months analysis\n# six_mo &lt;- survfit(Surv(AVAL, 1-CNSR) ~ ARM, adtte) |&gt; ard_survival_survfit(time = 6)\n\n\n\n\n\n\n\n\nShow the code\n# event rate table\nrtables_event_rate &lt;-  rtables_results |&gt;\n  filter(variable_label == \"Patients with event (%)\" | variable_label == \"Patients without event (%)\" | group1_level == \"Patients with event (%)\") |&gt;\n  dplyr::rename(group1 = group2,\n                group1_level = group2_level,\n                # rename other vars to avoid error\n                group2 = group1,\n                group2_level = group1_level) |&gt;\n  dplyr::select(c(group1, group1_level, variable, stat_name, stat))|&gt;\n  dplyr::mutate(stat_name = dplyr::recode(stat_name, \"count\" = \"n\"),\n                stat_name = dplyr::recode(stat_name, \"fraction\" = \"p\"))\n\n# time to event table ### need to simplify this code\n\nrtables_time_to_event &lt;- rtables_results |&gt;\n  filter(variable == \"time_to_event\") |&gt;\n  dplyr::rename(group1 = group2,\n                group1_level = group2_level,\n                # rename other vars to avoid error\n                group2 = group1,\n                group2_level = group1_level) |&gt;\n  group_by(variable_level == \"95% CI\")%&gt;%\n mutate(\n    variable_level = case_when(\n      variable_level == \"95% CI\" & row_number() == 1 ~ \"conf.low\",\n      variable_level == \"95% CI\" & row_number() == 2 ~ \"conf.high\",\n      TRUE ~ variable_level  # Keep original values for rows that aren't \"95% CI\"\n    )\n  ) %&gt;%\n  ungroup() |&gt; group_by(variable_level == \"Range\") %&gt;%\n mutate(\n    variable_level = case_when(\n      variable_level == \"Range\" & row_number() == 1 ~ \"min\",\n      variable_level == \"Range\" & row_number() == 2 ~ \"max\",\n      TRUE ~ variable_level  # Keep original values for rows that aren't \"95% CI\"\n    )) |&gt;\n  ungroup() |&gt;\n  group_by(variable_level == \"25% and 75%-ile\") %&gt;%\n mutate(\n    variable_level = case_when(\n      variable_level == \"Range\" & row_number() == 1 ~ \"0.25\",\n      variable_level == \"Range\" & row_number() == 2 ~ \"0.75\",\n      TRUE ~ variable_level  # Keep original values for rows that aren't \"95% CI\"\n    )) |&gt;\n  ungroup() |&gt;\n  mutate(variable_level = recode(variable_level, \"Median\" = \"estimate\")) |&gt;\ndplyr::select(c(group1, group1_level, variable_level, stat_name, stat))\n\n\n\n\n\n\nShow the code\nard_event_rates &lt;- ard_event_rates |&gt;\n   mutate(\n    variable = recode(variable, \"is_event\" = \"IS_EVENT\"),\n    variable = ifelse(variable_level == FALSE & variable != \"EVNTDESC\", \"IS_NOT_EVENT\", variable),\n                group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n                 stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_))\n                ) |&gt;\n  dplyr::select(c(\"group1\", \"group1_level\", \"variable\", \"stat_name\", \"stat\"))\n\nard_tte &lt;- ard_tte |&gt;\n  mutate(\n                group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n                 stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_))\n                )\n\n\n\n\n\n\n\n\nShow the code\n# library(diffdf)\n# \n# # event rate tables\n# diffdf(rtables_event_rate, ard_event_rates, keys = c(\"group1\", \"group1_level\", \"variable\", \"stat_name\", \"stat\"), suppress_warnings = TRUE)\n# \n# # time to event tables\n# diffdf(rtables_time_to_event, ard_tte, keys = c(\"group1\", \"group1_level\", \"variable_level\", \"stat_name\", \"stat\"), suppress_warnings = TRUE)",
    "crumbs": [
      "Time-to-Event Table"
    ]
  },
  {
    "objectID": "quarto/04-QC-TTET01.html#time-to-event-summary-ttet01-qc-workflow",
    "href": "quarto/04-QC-TTET01.html#time-to-event-summary-ttet01-qc-workflow",
    "title": "QCing Time-to-event Summary (TTET01)",
    "section": "",
    "text": "Show the code\nlibrary(chevron)\n\n# Create a table using the chevron package \nproc_data &lt;- dunlin::log_filter(syn_data, PARAMCD == \"PFS\", \"adtte\")\ntlg_ttet01 &lt;- chevron::run(ttet01, proc_data)\ntlg_ttet01\n\n\n                                      A: Drug X        B: Placebo      C: Combination \n                                        (N=15)           (N=15)            (N=15)     \n  ————————————————————————————————————————————————————————————————————————————————————\n  Patients with event (%)             7 (46.7%)         12 (80%)          8 (53.3%)   \n    Earliest contributing event                                                       \n      Death                               5                11                 7       \n      Disease Progression                 2                 1                 1       \n  Patients without event (%)          8 (53.3%)          3 (20%)          7 (46.7%)   \n  Time to Event (MONTHS)                                                              \n    Median                               8.6               6.2               8.4      \n      95% CI                          (7.3, NE)        (4.8, 7.6)         (7.0, NE)   \n    25% and 75%-ile                    3.8, NE          4.7, 8.4           5.8, NE    \n    Range                           1.2 to 9.5 {1}     0.9 to 9.1      0.9 to 9.5 {1} \n  Unstratified Analysis                                                               \n    p-value (log-rank)                                   0.0973            0.9111     \n    Hazard Ratio                                          2.18              1.06      \n    95% CI                                            (0.85, 5.60)      (0.38, 2.94)  \n  6 MONTHS                                                                            \n    Patients remaining at risk            11                8                11       \n    Event Free Rate (%)                 73.33             53.33             73.33     \n    95% CI                          (50.95, 95.71)   (28.09, 78.58)    (50.95, 95.71) \n    Difference in Event Free Rate                        -20.00             0.00      \n      95% CI                                         (-53.74, 13.74)   (-31.65, 31.65)\n      p-value (Z-test)                                   0.2453            1.0000     \n  ————————————————————————————————————————————————————————————————————————————————————\n\n  {1} - Censored observation: range maximum\n  ————————————————————————————————————————————————————————————————————————————————————\n\n\n\n\n\nA rtables based output can be flattened into a data frame using the as_results_df() function from the rtables package. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards} package.\n\n\nShow the code\nrtables_results &lt;- rtables::as_result_df(tlg_ttet01, make_ard = TRUE, add_tbl_str_decimals = FALSE)\n\n\n\n\n\nUsing the {cards} package, we stack the functions ard_continuous() for the continuous variables and ard_categorical() for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.\nIf any variable manipulation was done to the data prior to running the citril/chevron/tern/rtables commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.\nNote: when a ‘by’ variable is specified in the ard_stack() call, a univariate tabluation is returned. We will have to remove those obervations later in the workflow to create a 1:1 match.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(cards)\nlibrary(cardx)\nlibrary(survival)\n\n\nadtte &lt;- proc_data$adtte |&gt;\n  dplyr::mutate(AVAL = (AVAL/ 30.4375), #convert days to months, this is the same calculation chevron uses.\n                is_event = CNSR == 0, # chevron coding of events\n                is_not_event = CNSR == 1)\n\n# Event Rates\nard_event_rates &lt;- bind_ard(\n  # Patient Event Rates\n  ard_categorical(adtte, strata = c(ARM), variable = c(is_event), statistic = everything()~c(\"n\", \"p\")),\n  # Earliest Contributing Event\n  ard_categorical(adtte |&gt; dplyr::filter(is_event == TRUE), strata = c(ARM), variable = c(EVNTDESC), statistic = everything()~c(\"n\"))\n)\n \n\n# Time to Event\nard_tte &lt;- bind_ard(\n  # calculate median\n  survfit(Surv(AVAL, 1-CNSR) ~ ARM, data = adtte) |&gt;\n  ard_survival_survfit(probs = 0.5), \n  # calculate quantiles\n  survfit(Surv(AVAL, 1-CNSR) ~ ARM, data = adtte) |&gt;\n  ard_survival_survfit(probs = c(0.25, 0.75)) |&gt;\n  filter(stat_name == \"estimate\"),\n  # calculate range\n  ard_continuous(adtte, by = c(ARM), variable = c(AVAL), statistic = ~ continuous_summary_fns(c(\"min\", \"max\")))\n)\n\n# Unstratified Analysis\nard_logrank &lt;-\n  ard_survival_survdiff(\n    formula = Surv(AVAL, CNSR) ~ ARM,\n    data = adtte\n  )\n\n# difference in event free rate\n# event_free &lt;- survfit(Surv_CNSR() ~ ARM, data = adtte) |&gt;\n#   ard_survival_survfit_diff(times = 6) |&gt;\n#   filter(stat_name %in% c(\"estimate\", \"conf.low\", \"conf.high\", \"p.value\"))\n\n\n# unstratified pairwise\n# surv_fit &lt;- coxph(Surv(AVAL, is_event) ~ ARM, data = adtte_f)\nlibrary(cardx)\nlibrary(survival)\n\n  \n# ard_coxph &lt;-\n#   coxph(Surv(AVAL, 1 - CNSR) ~ ARM, data = adtte) |&gt; \n#   ard_regression() |&gt; \n#   dplyr::filter(stat_name %in% c(\"estimate\", \"conf.low\", \"conf.high\"))\n# \n# # 6 months analysis\n# six_mo &lt;- survfit(Surv(AVAL, 1-CNSR) ~ ARM, adtte) |&gt; ard_survival_survfit(time = 6)\n\n\n\n\n\n\n\n\nShow the code\n# event rate table\nrtables_event_rate &lt;-  rtables_results |&gt;\n  filter(variable_label == \"Patients with event (%)\" | variable_label == \"Patients without event (%)\" | group1_level == \"Patients with event (%)\") |&gt;\n  dplyr::rename(group1 = group2,\n                group1_level = group2_level,\n                # rename other vars to avoid error\n                group2 = group1,\n                group2_level = group1_level) |&gt;\n  dplyr::select(c(group1, group1_level, variable, stat_name, stat))|&gt;\n  dplyr::mutate(stat_name = dplyr::recode(stat_name, \"count\" = \"n\"),\n                stat_name = dplyr::recode(stat_name, \"fraction\" = \"p\"))\n\n# time to event table ### need to simplify this code\n\nrtables_time_to_event &lt;- rtables_results |&gt;\n  filter(variable == \"time_to_event\") |&gt;\n  dplyr::rename(group1 = group2,\n                group1_level = group2_level,\n                # rename other vars to avoid error\n                group2 = group1,\n                group2_level = group1_level) |&gt;\n  group_by(variable_level == \"95% CI\")%&gt;%\n mutate(\n    variable_level = case_when(\n      variable_level == \"95% CI\" & row_number() == 1 ~ \"conf.low\",\n      variable_level == \"95% CI\" & row_number() == 2 ~ \"conf.high\",\n      TRUE ~ variable_level  # Keep original values for rows that aren't \"95% CI\"\n    )\n  ) %&gt;%\n  ungroup() |&gt; group_by(variable_level == \"Range\") %&gt;%\n mutate(\n    variable_level = case_when(\n      variable_level == \"Range\" & row_number() == 1 ~ \"min\",\n      variable_level == \"Range\" & row_number() == 2 ~ \"max\",\n      TRUE ~ variable_level  # Keep original values for rows that aren't \"95% CI\"\n    )) |&gt;\n  ungroup() |&gt;\n  group_by(variable_level == \"25% and 75%-ile\") %&gt;%\n mutate(\n    variable_level = case_when(\n      variable_level == \"Range\" & row_number() == 1 ~ \"0.25\",\n      variable_level == \"Range\" & row_number() == 2 ~ \"0.75\",\n      TRUE ~ variable_level  # Keep original values for rows that aren't \"95% CI\"\n    )) |&gt;\n  ungroup() |&gt;\n  mutate(variable_level = recode(variable_level, \"Median\" = \"estimate\")) |&gt;\ndplyr::select(c(group1, group1_level, variable_level, stat_name, stat))\n\n\n\n\n\n\nShow the code\nard_event_rates &lt;- ard_event_rates |&gt;\n   mutate(\n    variable = recode(variable, \"is_event\" = \"IS_EVENT\"),\n    variable = ifelse(variable_level == FALSE & variable != \"EVNTDESC\", \"IS_NOT_EVENT\", variable),\n                group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n                 stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_))\n                ) |&gt;\n  dplyr::select(c(\"group1\", \"group1_level\", \"variable\", \"stat_name\", \"stat\"))\n\nard_tte &lt;- ard_tte |&gt;\n  mutate(\n                group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n                 stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_))\n                )\n\n\n\n\n\n\n\n\nShow the code\n# library(diffdf)\n# \n# # event rate tables\n# diffdf(rtables_event_rate, ard_event_rates, keys = c(\"group1\", \"group1_level\", \"variable\", \"stat_name\", \"stat\"), suppress_warnings = TRUE)\n# \n# # time to event tables\n# diffdf(rtables_time_to_event, ard_tte, keys = c(\"group1\", \"group1_level\", \"variable_level\", \"stat_name\", \"stat\"), suppress_warnings = TRUE)",
    "crumbs": [
      "Time-to-Event Table"
    ]
  },
  {
    "objectID": "quarto/01-QC-DMT01.html",
    "href": "quarto/01-QC-DMT01.html",
    "title": "QCing Demographics and Baseline Characteristics (DMT01)",
    "section": "",
    "text": "Show the code\nlibrary(chevron)\n\n# Create a table using the chevron package \ntlg_dmt01 &lt;- chevron::dmt01_main(syn_data, summaryvars = c(\"AGE\", \"AGEGR1\", \"SEX\", \"ETHNIC\", \"RACE\"))\nhead(tlg_dmt01, n=15)\n\n\n              A: Drug X    B: Placebo   C: Combination   All Patients\n                (N=15)       (N=15)         (N=15)          (N=45)   \n—————————————————————————————————————————————————————————————————————\nAge                                                                  \n  n               15           15             15              45     \n  Mean (SD)   31.3 (5.3)   35.1 (9.0)     36.6 (6.4)      34.3 (7.3) \n  Median         31.0         35.0           35.0            34.0    \n  Min - Max    24 - 40      24 - 57        24 - 49         24 - 57   \nAge Group                                                            \n  n               15           15             15              45     \n  &lt;65         15 (100%)    15 (100%)      15 (100%)       45 (100%)  \n  &gt;=65            0            0              0               0      \nSex                                                                  \n  n               15           15             15              45     \n  F           12 (80.0%)   8 (53.3%)      10 (66.7%)      30 (66.7%) \n  M           3 (20.0%)    7 (46.7%)      5 (33.3%)       15 (33.3%) \nEthnicity                                                            \n  n               15           15             15              45     \n\n\n\n\n\nA {rtables} based output can be flattened into a data.frame using the as_results_df() function from the {rtables} package. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards} package.\n\nrtables_result &lt;- rtables::as_result_df(tlg_dmt01, make_ard = TRUE, add_tbl_str_decimals = FALSE)\nrtables_result[1:6, -c(2:4)]\n\n\n\n\n\ngroup1\nvariable_label\nstat_name\nstat\n\n\n\n\nARM\nn\nn\n15.000000\n\n\nARM\nMean (SD)\nmean\n31.333333\n\n\nARM\nMean (SD)\nsd\n5.259911\n\n\nARM\nMedian\nmedian\n31.000000\n\n\nARM\nMin - Max\nmin\n24.000000\n\n\nARM\nMin - Max\nmax\n40.000000\n\n\n\n\n\n\n\n\n\nUsing the {cards} package, we stack the functions ard_continuous() for the continuous variables and ard_categorical() for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.\nIf any variable manipulation was done to the data prior to running the {citril}/{chevron}/{tern}/{rtables} commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.\nNote: when a by variable is specified in the ard_stack() call, a univariate tabluation is returned. We will have to remove those observations later in the workflow to create a 1:1 match.\n\nlibrary(cards)\n\n# build ARDs that calculate relevant statistics for continuous and categorical variables.\nard_result &lt;- \n  ard_stack(\n    syn_data$adsl, \n    ard_continuous(variables = c(AGE), \n                   statistic = ~ continuous_summary_fns(c(\"N\", \"mean\", \"sd\", \"median\", \"min\", \"max\"))),\n    ard_categorical(variables = c(AGEGR1, SEX, ETHNIC, RACE), statistic =everything() ~ c(\"n\", \"p\")),\n    ard_missing(variables = c(AGEGR1, SEX, ETHNIC, RACE), statistic = everything()~ c(\"N_obs\")),\n    .by = \"ARM\",\n    .overall = TRUE)\n\nard_result[1:6, -c(1, 9:11)]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroup1_level\nvariable\nvariable_level\ncontext\nstat_name\nstat_label\nstat\n\n\n\n\n1\nAGE\nNULL\ncontinuous\nN\nN\n15\n\n\n1\nAGE\nNULL\ncontinuous\nmean\nMean\n31.33333\n\n\n1\nAGE\nNULL\ncontinuous\nsd\nSD\n5.259911\n\n\n1\nAGE\nNULL\ncontinuous\nmedian\nMedian\n31\n\n\n1\nAGE\nNULL\ncontinuous\nmin\nMin\n24\n\n\n1\nAGE\nNULL\ncontinuous\nmax\nMax\n40\n\n\n\n\n\n\n\n\n\n\n\nIn order to compare the two data.frames programatically, some identifying variables must align to be used as “key columns”. Below are some data wrangling steps used to match the statistics for comparison. Note the {rtables} output:\n\n\nShow the code\ntail(rtables_result[, -c(1:2)])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvariable\nvariable_level\nvariable_label\nstat_name\nstat\n\n\n\n\n131\nRACE\ncount_fraction.ASIAN\nASIAN\ncount\n26.0000000\n\n\n132\nRACE\ncount_fraction.ASIAN\nASIAN\np\n0.5777778\n\n\n133\nRACE\ncount_fraction.BLACK OR AFRICAN AMERICAN\nBLACK OR AFRICAN AMERICAN\ncount\n9.0000000\n\n\n134\nRACE\ncount_fraction.BLACK OR AFRICAN AMERICAN\nBLACK OR AFRICAN AMERICAN\np\n0.2000000\n\n\n135\nRACE\ncount_fraction.WHITE\nWHITE\ncount\n7.0000000\n\n\n136\nRACE\ncount_fraction.WHITE\nWHITE\np\n0.1555556\n\n\n\n\n\n\nThe variable_level leads with the statistic name, followed by \".\" and then the actual level that matches the variable_level in the ARD object. We will mutate the level to match the level values in the ARD object. Similarly, the total number of observations for a group is labelled \"N\" in the ARD object, while it is named \"n\" in the {rtables} object. The following manipulations are completed below:\n\nSet the variable_level to NA in the {rtables} result for a continuous data summary (as variable levels don’t apply and is NULL in the ARD object).\nRemove the stat_name (ie. “count”) before the variable level.\nConvert the “n”:“N” and “count”:“n”.\nRemove columns we know won’t be in the ARD data.frame for simplicity (ie.variable label)\n\n\n\nShow the code\nrtables_result &lt;- rtables_result |&gt;\n  dplyr::mutate(\n    variable_level = dplyr::case_when(\n      variable == \"AGE\" & variable_level %in% c(\"mean_sd\", \"median\", \"range\", \"n\") ~ NA_character_,\n      TRUE ~ variable_level\n    ),\n    variable_level = sub(\"^[^.]*\\\\.\", \"\", variable_level),  # use variable_label\n    stat_name = dplyr::recode(stat_name, \"n\" = \"N\", \"count\" = \"n\")\n  ) |&gt;\n  dplyr::select(-c(\"variable_label\"))\n\nhead(rtables_result, n=5)\n\n\n\n\n\n\ngroup1\ngroup1_level\nvariable\nvariable_level\nstat_name\nstat\n\n\n\n\nARM\nA: Drug X\nAGE\nNA\nN\n15.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmean\n31.333333\n\n\nARM\nA: Drug X\nAGE\nNA\nsd\n5.259911\n\n\nARM\nA: Drug X\nAGE\nNA\nmedian\n31.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmin\n24.000000\n\n\n\n\n\n\n\n\n\nA reformatting step is necessary for the ARD output to complete the comparison. Note that many of the columns in the {cards} objects are a list (for example, the level of the variable followed by the levels available for the factor).\n\n\nShow the code\nard_result$group1_level[1]\n\n\n[[1]]\n[1] A: Drug X\nLevels: A: Drug X B: Placebo C: Combination\n\n\nWe will pull the first string from the lis (group1_level, variable_level). We’ll also add the string “ARM” to any NULL observations in the group1 column to match the {rtables} result.\n\n\nShow the code\nard_result &lt;- ard_result |&gt;\n  dplyr::mutate(\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    variable_level = purrr::map_chr(variable_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    group1 = dplyr::coalesce(group1, \"ARM\"),\n    group1_level = dplyr::coalesce(group1_level, \"All Patients\"),\n    stat_name = dplyr::recode(stat_name, \"N_obs\" = \"N\")\n  ) |&gt;\n  dplyr::select(-c(\"context\", \"fmt_fn\", \"stat_label\", \"warning\", \"error\"))\n\nhead(ard_result, n=5)\n\n\n\n\n\n\ngroup1\ngroup1_level\nvariable\nvariable_level\nstat_name\nstat\n\n\n\n\nARM\nA: Drug X\nAGE\nNA\nN\n15.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmean\n31.333333\n\n\nARM\nA: Drug X\nAGE\nNA\nsd\n5.259911\n\n\nARM\nA: Drug X\nAGE\nNA\nmedian\n31.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmin\n24.000000\n\n\n\n\n\n\nShow the code\nprint(\"ARD dimensions\")\n\n\n[1] \"ARD dimensions\"\n\n\nShow the code\ndim(ard_result)\n\n\n[1] 145   6\n\n\nShow the code\nprint(\"rtables Dimensions\")\n\n\n[1] \"rtables Dimensions\"\n\n\nShow the code\ndim(rtables_result)\n\n\n[1] 136   6\n\n\nNote that the ARD result is larger than the {rtables} result. When using ard_stack with a listed by variable, a univariate analysis is run for that variable. Here, it is \"ARM\". We can remove those statistics as they are not in the rtables_result.\n\nard_result &lt;- ard_result |&gt;  \ndplyr::filter(\n    !((variable == \"ARM\") ) | is.na(variable_level))|&gt;\n   dplyr::mutate(variable_level = dplyr::if_else(stat_name == 'N' & is.na(variable_level) & variable != \"AGE\", 'n', variable_level))\n\n\n\n\nHere we propose using the {diffdf} package to compare the statistics produced by the two table engines. {diffdf} is designed to compare two data.frames and report any differences/inconsistencies to the user.\n\nlibrary(diffdf)\n\ndiffdf(rtables_result, ard_result, keys = c(\"group1_level\",\"group1\", \"variable\", \"variable_level\", \"stat_name\"), suppress_warnings = TRUE)\n\nNo issues were found!\n\n\nThe anti_join() function from the {dplyr} package can be used to isolate the differences between the two data.frames for closer analysis.\n\nlibrary(dplyr)\n\ndifferences &lt;- ard_result %&gt;% #start with the data.frames which contain greater number of rows.\n  dplyr::anti_join(rtables_result, \n                   # Compare based on key columns\n                   by = c(\"group1_level\",\"group1\", \"variable\", \"variable_level\", \"stat_name\")) \ndifferences\n\n\n\n\n\ngroup1\ngroup1_level\nvariable\nvariable_level\nstat_name\nstat",
    "crumbs": [
      "Demographics Table"
    ]
  },
  {
    "objectID": "quarto/01-QC-DMT01.html#demographics-and-baseline-characteristics-dmt01-qc-workflow",
    "href": "quarto/01-QC-DMT01.html#demographics-and-baseline-characteristics-dmt01-qc-workflow",
    "title": "QCing Demographics and Baseline Characteristics (DMT01)",
    "section": "",
    "text": "Show the code\nlibrary(chevron)\n\n# Create a table using the chevron package \ntlg_dmt01 &lt;- chevron::dmt01_main(syn_data, summaryvars = c(\"AGE\", \"AGEGR1\", \"SEX\", \"ETHNIC\", \"RACE\"))\nhead(tlg_dmt01, n=15)\n\n\n              A: Drug X    B: Placebo   C: Combination   All Patients\n                (N=15)       (N=15)         (N=15)          (N=45)   \n—————————————————————————————————————————————————————————————————————\nAge                                                                  \n  n               15           15             15              45     \n  Mean (SD)   31.3 (5.3)   35.1 (9.0)     36.6 (6.4)      34.3 (7.3) \n  Median         31.0         35.0           35.0            34.0    \n  Min - Max    24 - 40      24 - 57        24 - 49         24 - 57   \nAge Group                                                            \n  n               15           15             15              45     \n  &lt;65         15 (100%)    15 (100%)      15 (100%)       45 (100%)  \n  &gt;=65            0            0              0               0      \nSex                                                                  \n  n               15           15             15              45     \n  F           12 (80.0%)   8 (53.3%)      10 (66.7%)      30 (66.7%) \n  M           3 (20.0%)    7 (46.7%)      5 (33.3%)       15 (33.3%) \nEthnicity                                                            \n  n               15           15             15              45     \n\n\n\n\n\nA {rtables} based output can be flattened into a data.frame using the as_results_df() function from the {rtables} package. The make_ard argument set to TRUE, will format the data similar to the output generated by the {cards} package.\n\nrtables_result &lt;- rtables::as_result_df(tlg_dmt01, make_ard = TRUE, add_tbl_str_decimals = FALSE)\nrtables_result[1:6, -c(2:4)]\n\n\n\n\n\ngroup1\nvariable_label\nstat_name\nstat\n\n\n\n\nARM\nn\nn\n15.000000\n\n\nARM\nMean (SD)\nmean\n31.333333\n\n\nARM\nMean (SD)\nsd\n5.259911\n\n\nARM\nMedian\nmedian\n31.000000\n\n\nARM\nMin - Max\nmin\n24.000000\n\n\nARM\nMin - Max\nmax\n40.000000\n\n\n\n\n\n\n\n\n\nUsing the {cards} package, we stack the functions ard_continuous() for the continuous variables and ard_categorical() for categorical variables. The default statistics calculated for each of these data types are included - these can be adapted for bespoke analyses.\nIf any variable manipulation was done to the data prior to running the {citril}/{chevron}/{tern}/{rtables} commands, we suggest supplying the same data to these ARD functions, or running the same pre-processing steps to your data prior to creating ARDs to ensure variable names/levels match.\nNote: when a by variable is specified in the ard_stack() call, a univariate tabluation is returned. We will have to remove those observations later in the workflow to create a 1:1 match.\n\nlibrary(cards)\n\n# build ARDs that calculate relevant statistics for continuous and categorical variables.\nard_result &lt;- \n  ard_stack(\n    syn_data$adsl, \n    ard_continuous(variables = c(AGE), \n                   statistic = ~ continuous_summary_fns(c(\"N\", \"mean\", \"sd\", \"median\", \"min\", \"max\"))),\n    ard_categorical(variables = c(AGEGR1, SEX, ETHNIC, RACE), statistic =everything() ~ c(\"n\", \"p\")),\n    ard_missing(variables = c(AGEGR1, SEX, ETHNIC, RACE), statistic = everything()~ c(\"N_obs\")),\n    .by = \"ARM\",\n    .overall = TRUE)\n\nard_result[1:6, -c(1, 9:11)]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngroup1_level\nvariable\nvariable_level\ncontext\nstat_name\nstat_label\nstat\n\n\n\n\n1\nAGE\nNULL\ncontinuous\nN\nN\n15\n\n\n1\nAGE\nNULL\ncontinuous\nmean\nMean\n31.33333\n\n\n1\nAGE\nNULL\ncontinuous\nsd\nSD\n5.259911\n\n\n1\nAGE\nNULL\ncontinuous\nmedian\nMedian\n31\n\n\n1\nAGE\nNULL\ncontinuous\nmin\nMin\n24\n\n\n1\nAGE\nNULL\ncontinuous\nmax\nMax\n40\n\n\n\n\n\n\n\n\n\n\n\nIn order to compare the two data.frames programatically, some identifying variables must align to be used as “key columns”. Below are some data wrangling steps used to match the statistics for comparison. Note the {rtables} output:\n\n\nShow the code\ntail(rtables_result[, -c(1:2)])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvariable\nvariable_level\nvariable_label\nstat_name\nstat\n\n\n\n\n131\nRACE\ncount_fraction.ASIAN\nASIAN\ncount\n26.0000000\n\n\n132\nRACE\ncount_fraction.ASIAN\nASIAN\np\n0.5777778\n\n\n133\nRACE\ncount_fraction.BLACK OR AFRICAN AMERICAN\nBLACK OR AFRICAN AMERICAN\ncount\n9.0000000\n\n\n134\nRACE\ncount_fraction.BLACK OR AFRICAN AMERICAN\nBLACK OR AFRICAN AMERICAN\np\n0.2000000\n\n\n135\nRACE\ncount_fraction.WHITE\nWHITE\ncount\n7.0000000\n\n\n136\nRACE\ncount_fraction.WHITE\nWHITE\np\n0.1555556\n\n\n\n\n\n\nThe variable_level leads with the statistic name, followed by \".\" and then the actual level that matches the variable_level in the ARD object. We will mutate the level to match the level values in the ARD object. Similarly, the total number of observations for a group is labelled \"N\" in the ARD object, while it is named \"n\" in the {rtables} object. The following manipulations are completed below:\n\nSet the variable_level to NA in the {rtables} result for a continuous data summary (as variable levels don’t apply and is NULL in the ARD object).\nRemove the stat_name (ie. “count”) before the variable level.\nConvert the “n”:“N” and “count”:“n”.\nRemove columns we know won’t be in the ARD data.frame for simplicity (ie.variable label)\n\n\n\nShow the code\nrtables_result &lt;- rtables_result |&gt;\n  dplyr::mutate(\n    variable_level = dplyr::case_when(\n      variable == \"AGE\" & variable_level %in% c(\"mean_sd\", \"median\", \"range\", \"n\") ~ NA_character_,\n      TRUE ~ variable_level\n    ),\n    variable_level = sub(\"^[^.]*\\\\.\", \"\", variable_level),  # use variable_label\n    stat_name = dplyr::recode(stat_name, \"n\" = \"N\", \"count\" = \"n\")\n  ) |&gt;\n  dplyr::select(-c(\"variable_label\"))\n\nhead(rtables_result, n=5)\n\n\n\n\n\n\ngroup1\ngroup1_level\nvariable\nvariable_level\nstat_name\nstat\n\n\n\n\nARM\nA: Drug X\nAGE\nNA\nN\n15.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmean\n31.333333\n\n\nARM\nA: Drug X\nAGE\nNA\nsd\n5.259911\n\n\nARM\nA: Drug X\nAGE\nNA\nmedian\n31.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmin\n24.000000\n\n\n\n\n\n\n\n\n\nA reformatting step is necessary for the ARD output to complete the comparison. Note that many of the columns in the {cards} objects are a list (for example, the level of the variable followed by the levels available for the factor).\n\n\nShow the code\nard_result$group1_level[1]\n\n\n[[1]]\n[1] A: Drug X\nLevels: A: Drug X B: Placebo C: Combination\n\n\nWe will pull the first string from the lis (group1_level, variable_level). We’ll also add the string “ARM” to any NULL observations in the group1 column to match the {rtables} result.\n\n\nShow the code\nard_result &lt;- ard_result |&gt;\n  dplyr::mutate(\n    group1_level = purrr::map_chr(group1_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    variable_level = purrr::map_chr(variable_level, ~ ifelse(length(.x) &gt; 0, as.character(.x[[1]]), NA_character_)),\n    stat = purrr::map_dbl(stat, ~ ifelse(length(.x) &gt; 0, as.numeric(.x[[1]]), NA_character_)),\n    group1 = dplyr::coalesce(group1, \"ARM\"),\n    group1_level = dplyr::coalesce(group1_level, \"All Patients\"),\n    stat_name = dplyr::recode(stat_name, \"N_obs\" = \"N\")\n  ) |&gt;\n  dplyr::select(-c(\"context\", \"fmt_fn\", \"stat_label\", \"warning\", \"error\"))\n\nhead(ard_result, n=5)\n\n\n\n\n\n\ngroup1\ngroup1_level\nvariable\nvariable_level\nstat_name\nstat\n\n\n\n\nARM\nA: Drug X\nAGE\nNA\nN\n15.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmean\n31.333333\n\n\nARM\nA: Drug X\nAGE\nNA\nsd\n5.259911\n\n\nARM\nA: Drug X\nAGE\nNA\nmedian\n31.000000\n\n\nARM\nA: Drug X\nAGE\nNA\nmin\n24.000000\n\n\n\n\n\n\nShow the code\nprint(\"ARD dimensions\")\n\n\n[1] \"ARD dimensions\"\n\n\nShow the code\ndim(ard_result)\n\n\n[1] 145   6\n\n\nShow the code\nprint(\"rtables Dimensions\")\n\n\n[1] \"rtables Dimensions\"\n\n\nShow the code\ndim(rtables_result)\n\n\n[1] 136   6\n\n\nNote that the ARD result is larger than the {rtables} result. When using ard_stack with a listed by variable, a univariate analysis is run for that variable. Here, it is \"ARM\". We can remove those statistics as they are not in the rtables_result.\n\nard_result &lt;- ard_result |&gt;  \ndplyr::filter(\n    !((variable == \"ARM\") ) | is.na(variable_level))|&gt;\n   dplyr::mutate(variable_level = dplyr::if_else(stat_name == 'N' & is.na(variable_level) & variable != \"AGE\", 'n', variable_level))\n\n\n\n\nHere we propose using the {diffdf} package to compare the statistics produced by the two table engines. {diffdf} is designed to compare two data.frames and report any differences/inconsistencies to the user.\n\nlibrary(diffdf)\n\ndiffdf(rtables_result, ard_result, keys = c(\"group1_level\",\"group1\", \"variable\", \"variable_level\", \"stat_name\"), suppress_warnings = TRUE)\n\nNo issues were found!\n\n\nThe anti_join() function from the {dplyr} package can be used to isolate the differences between the two data.frames for closer analysis.\n\nlibrary(dplyr)\n\ndifferences &lt;- ard_result %&gt;% #start with the data.frames which contain greater number of rows.\n  dplyr::anti_join(rtables_result, \n                   # Compare based on key columns\n                   by = c(\"group1_level\",\"group1\", \"variable\", \"variable_level\", \"stat_name\")) \ndifferences\n\n\n\n\n\ngroup1\ngroup1_level\nvariable\nvariable_level\nstat_name\nstat",
    "crumbs": [
      "Demographics Table"
    ]
  }
]